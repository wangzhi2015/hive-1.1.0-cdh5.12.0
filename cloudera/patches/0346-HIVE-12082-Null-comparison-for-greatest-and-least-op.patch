From a4efa482719c1d35d124b4c8ff727b2c52edf263 Mon Sep 17 00:00:00 2001
From: Szehon Ho <szehon@cloudera.com>
Date: Thu, 15 Oct 2015 11:19:37 -0700
Subject: [PATCH 0346/1164] HIVE-12082 : Null comparison for greatest and
 least operator (Szehon, reviewed by Xuefu)

---
 .../ql/udf/generic/GenericUDFBaseNwayCompare.java  |  115 +++++++++++++++
 .../hive/ql/udf/generic/GenericUDFGreatest.java    |   75 +---------
 .../hive/ql/udf/generic/GenericUDFLeast.java       |    9 +-
 .../ql/udf/generic/TestGenericUDFGreatest.java     |  153 +++++++++++++-------
 .../hive/ql/udf/generic/TestGenericUDFLeast.java   |  149 ++++++++++++-------
 .../queries/clientnegative/udf_greatest_error_2.q  |    2 +-
 .../queries/clientnegative/udf_greatest_error_3.q  |    1 -
 .../queries/clientnegative/udf_greatest_error_4.q  |    1 -
 ql/src/test/queries/clientpositive/udf_greatest.q  |   20 +++
 ql/src/test/queries/clientpositive/udf_least.q     |   20 +++
 .../clientnegative/udf_greatest_error_2.q.out      |    2 +-
 .../clientnegative/udf_greatest_error_3.q.out      |    1 -
 .../clientnegative/udf_greatest_error_4.q.out      |    1 -
 .../test/results/clientpositive/udf_greatest.q.out |   70 ++++++++-
 ql/src/test/results/clientpositive/udf_least.q.out |   70 ++++++++-
 15 files changed, 490 insertions(+), 199 deletions(-)
 create mode 100644 ql/src/java/org/apache/hadoop/hive/ql/udf/generic/GenericUDFBaseNwayCompare.java
 delete mode 100644 ql/src/test/queries/clientnegative/udf_greatest_error_3.q
 delete mode 100644 ql/src/test/queries/clientnegative/udf_greatest_error_4.q
 delete mode 100644 ql/src/test/results/clientnegative/udf_greatest_error_3.q.out
 delete mode 100644 ql/src/test/results/clientnegative/udf_greatest_error_4.q.out

diff --git a/ql/src/java/org/apache/hadoop/hive/ql/udf/generic/GenericUDFBaseNwayCompare.java b/ql/src/java/org/apache/hadoop/hive/ql/udf/generic/GenericUDFBaseNwayCompare.java
new file mode 100644
index 0000000..5d542aa
--- /dev/null
+++ b/ql/src/java/org/apache/hadoop/hive/ql/udf/generic/GenericUDFBaseNwayCompare.java
@@ -0,0 +1,115 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hive.ql.udf.generic;
+
+import org.apache.hadoop.hive.ql.exec.FunctionRegistry;
+import org.apache.hadoop.hive.ql.exec.UDFArgumentException;
+import org.apache.hadoop.hive.ql.exec.UDFArgumentLengthException;
+import org.apache.hadoop.hive.ql.metadata.HiveException;
+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;
+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorConverters;
+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorConverters.Converter;
+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorUtils;
+import org.apache.hadoop.hive.serde2.typeinfo.PrimitiveTypeInfo;
+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfo;
+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfoFactory;
+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfoUtils;
+
+
+/**
+ * Base class for comparison UDF's (Greatest and Least).
+ */
+public abstract class GenericUDFBaseNwayCompare extends GenericUDF {
+
+  protected transient ObjectInspector[] argumentOIs;
+  protected transient Converter[] converters;
+  protected transient ObjectInspector resultOI;
+
+  /**
+   * @return desired comparison (positive for greatest, negative for least)
+   */
+  abstract int getOrder();
+
+  @Override
+  public ObjectInspector initialize(ObjectInspector[] arguments) throws UDFArgumentException {
+    if (arguments.length < 2) {
+      throw new UDFArgumentLengthException(getFuncName() + " requires at least 2 arguments, got "
+        + arguments.length);
+    }
+    if (arguments[0].getCategory() != ObjectInspector.Category.PRIMITIVE) {
+      throw new UDFArgumentException(getFuncName() + " only takes primitive types, got "
+        + arguments[0].getTypeName());
+    }
+
+    argumentOIs = arguments;
+    converters = new Converter[arguments.length];
+
+    TypeInfo commonInfo = TypeInfoUtils.getTypeInfoFromObjectInspector(arguments[0]);
+
+    for (int i = 1; i < arguments.length; i++) {
+      PrimitiveTypeInfo currInfo = (PrimitiveTypeInfo) TypeInfoUtils.getTypeInfoFromObjectInspector(arguments[i]);
+
+      commonInfo = FunctionRegistry.getCommonClassForComparison(
+        commonInfo, currInfo);
+    }
+
+    resultOI = TypeInfoUtils.getStandardWritableObjectInspectorFromTypeInfo(
+      (commonInfo == null) ?
+        TypeInfoFactory.doubleTypeInfo : commonInfo);
+
+    for (int i = 0; i < arguments.length; i++) {
+      converters[i] = ObjectInspectorConverters.getConverter(arguments[i], resultOI);
+    }
+
+    return resultOI;
+  }
+
+  @SuppressWarnings({ "rawtypes", "unchecked" })
+  @Override
+  public Object evaluate(GenericUDF.DeferredObject[] arguments) throws HiveException {
+    Object maxV = null;
+    //for case of conversion, convert both values to common type and then compare.
+    for (int i = 0; i < arguments.length; i++) {
+      Object ai = arguments[i].get();
+      if (ai == null) { //NULL if any of the args are nulls
+        return null;
+      }
+
+      if (maxV == null) { //First non-null item.
+        maxV = converters[i].convert(ai);
+        continue;
+      }
+      Object converted = converters[i].convert(ai);
+      if (converted == null) {
+        return null;
+      }
+      int result = ObjectInspectorUtils.compare(
+        converted, resultOI,
+        maxV, resultOI);
+      if (getOrder() * result > 0) {
+        maxV = converted;
+      }
+    }
+    return maxV;
+  }
+
+  @Override
+  public String getDisplayString(String[] children) {
+    return getStandardDisplayString(getFuncName(), children, ",");
+  }
+}
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/udf/generic/GenericUDFGreatest.java b/ql/src/java/org/apache/hadoop/hive/ql/udf/generic/GenericUDFGreatest.java
index e919345..39da1b0 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/udf/generic/GenericUDFGreatest.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/udf/generic/GenericUDFGreatest.java
@@ -19,89 +19,22 @@
 package org.apache.hadoop.hive.ql.udf.generic;
 
 import org.apache.hadoop.hive.ql.exec.Description;
-import org.apache.hadoop.hive.ql.exec.UDFArgumentException;
-import org.apache.hadoop.hive.ql.exec.UDFArgumentLengthException;
-import org.apache.hadoop.hive.ql.exec.UDFArgumentTypeException;
-import org.apache.hadoop.hive.ql.metadata.HiveException;
-import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;
-import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector.Category;
 
 /**
  * GenericUDF Class for SQL construct "greatest(v1, v2, .. vn)".
- *
- * NOTES: 1. v1, v2 and vn should have the same TypeInfo, or an exception will
- * be thrown.
  */
 @Description(name = "greatest",
     value = "_FUNC_(v1, v2, ...) - Returns the greatest value in a list of values",
     extended = "Example:\n"
     + "  > SELECT _FUNC_(2, 3, 1) FROM src LIMIT 1;\n" + "  3")
-public class GenericUDFGreatest extends GenericUDF {
-  private transient ObjectInspector[] argumentOIs;
-  private transient GenericUDFUtils.ReturnObjectInspectorResolver returnOIResolver;
-
-  @Override
-  public ObjectInspector initialize(ObjectInspector[] arguments) throws UDFArgumentException {
-    if (arguments.length < 2) {
-      throw new UDFArgumentLengthException(getFuncName() + " requires at least 2 arguments, got "
-          + arguments.length);
-    }
-    if (arguments[0].getCategory() != Category.PRIMITIVE) {
-      throw new UDFArgumentException(getFuncName() + " only takes primitive types, got "
-          + arguments[0].getTypeName());
-    }
-
-    argumentOIs = arguments;
-
-    returnOIResolver = new GenericUDFUtils.ReturnObjectInspectorResolver(false);
-    for (int i = 0; i < arguments.length; i++) {
-      if (!returnOIResolver.update(arguments[i])) {
-        throw new UDFArgumentTypeException(i, "The expressions after " + getFuncName()
-            + " should all have the same type: \"" + returnOIResolver.get().getTypeName()
-            + "\" is expected but \"" + arguments[i].getTypeName() + "\" is found");
-      }
-    }
-    return returnOIResolver.get();
-  }
-
-  @SuppressWarnings({ "rawtypes", "unchecked" })
-  @Override
-  public Object evaluate(DeferredObject[] arguments) throws HiveException {
-    Comparable maxV = null;
-    int maxIndex = 0;
-    for (int i = 0; i < arguments.length; i++) {
-      Object ai = arguments[i].get();
-      if (ai == null) {
-        continue;
-      }
-      // all PRIMITIVEs are Comparable
-      Comparable v = (Comparable) ai;
-      if (maxV == null) {
-        maxV = v;
-        maxIndex = i;
-        continue;
-      }
-      if ((isGreatest() ? 1 : -1) * v.compareTo(maxV) > 0) {
-        maxV = v;
-        maxIndex = i;
-      }
-    }
-    if (maxV != null) {
-      return returnOIResolver.convertIfNecessary(maxV, argumentOIs[maxIndex]);
-    }
-    return null;
-  }
-
-  @Override
-  public String getDisplayString(String[] children) {
-    return getStandardDisplayString(getFuncName(), children, ",");
-  }
+public class GenericUDFGreatest extends GenericUDFBaseNwayCompare {
 
   protected String getFuncName() {
     return "greatest";
   }
 
-  protected boolean isGreatest() {
-    return true;
+  @Override
+  protected int getOrder() {
+    return 1;
   }
 }
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/udf/generic/GenericUDFLeast.java b/ql/src/java/org/apache/hadoop/hive/ql/udf/generic/GenericUDFLeast.java
index 64a1b47..77f19e4 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/udf/generic/GenericUDFLeast.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/udf/generic/GenericUDFLeast.java
@@ -22,15 +22,12 @@
 
 /**
  * GenericUDF Class for SQL construct "least(v1, v2, .. vn)".
- *
- * NOTES: 1. v1, v2 and vn should have the same TypeInfo, or an exception will
- * be thrown.
  */
 @Description(name = "least",
     value = "_FUNC_(v1, v2, ...) - Returns the least value in a list of values",
     extended = "Example:\n"
     + "  > SELECT _FUNC_(2, 3, 1) FROM src LIMIT 1;\n" + "  1")
-public class GenericUDFLeast extends GenericUDFGreatest {
+public class GenericUDFLeast extends GenericUDFBaseNwayCompare {
 
   @Override
   protected String getFuncName() {
@@ -38,7 +35,7 @@ protected String getFuncName() {
   }
 
   @Override
-  protected boolean isGreatest() {
-    return false;
+  protected int getOrder() {
+    return -1;
   }
 }
diff --git a/ql/src/test/org/apache/hadoop/hive/ql/udf/generic/TestGenericUDFGreatest.java b/ql/src/test/org/apache/hadoop/hive/ql/udf/generic/TestGenericUDFGreatest.java
index 55d7d5d..15a58b2 100644
--- a/ql/src/test/org/apache/hadoop/hive/ql/udf/generic/TestGenericUDFGreatest.java
+++ b/ql/src/test/org/apache/hadoop/hive/ql/udf/generic/TestGenericUDFGreatest.java
@@ -17,21 +17,23 @@
  */
 package org.apache.hadoop.hive.ql.udf.generic;
 
-import java.sql.Date;
-
 import junit.framework.TestCase;
-
 import org.apache.hadoop.hive.ql.exec.UDFArgumentException;
 import org.apache.hadoop.hive.ql.metadata.HiveException;
 import org.apache.hadoop.hive.ql.udf.generic.GenericUDF.DeferredJavaObject;
 import org.apache.hadoop.hive.ql.udf.generic.GenericUDF.DeferredObject;
+import org.apache.hadoop.hive.serde2.io.ByteWritable;
 import org.apache.hadoop.hive.serde2.io.DateWritable;
 import org.apache.hadoop.hive.serde2.io.DoubleWritable;
+import org.apache.hadoop.hive.serde2.io.ShortWritable;
 import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;
 import org.apache.hadoop.hive.serde2.objectinspector.primitive.PrimitiveObjectInspectorFactory;
 import org.apache.hadoop.io.IntWritable;
+import org.apache.hadoop.io.LongWritable;
 import org.apache.hadoop.io.Text;
 
+import java.sql.Date;
+
 public class TestGenericUDFGreatest extends TestCase {
 
   public void testOneArg() throws HiveException {
@@ -49,22 +51,28 @@ public void testOneArg() throws HiveException {
     assertNotNull("greatest() test ", ex);
   }
 
-  public void testDifferentType() throws HiveException {
-    @SuppressWarnings("resource")
+  public void testVoids() throws HiveException {
+    GenericUDFGreatest udf = new GenericUDFGreatest();
+    ObjectInspector valueOI1 = PrimitiveObjectInspectorFactory.writableVoidObjectInspector;
+    ObjectInspector valueOI2 = PrimitiveObjectInspectorFactory.writableIntObjectInspector;
+    ObjectInspector valueOI3 = PrimitiveObjectInspectorFactory.writableStringObjectInspector;
+    ObjectInspector[] arguments = { valueOI1, valueOI2, valueOI3 };
+    udf.initialize(arguments);
+    runAndVerify(new Object[] { null, 1, "test"}, null, udf);
+  }
+
+  public void testGreatestMixed() throws HiveException {
     GenericUDFGreatest udf = new GenericUDFGreatest();
     ObjectInspector valueOI1 = PrimitiveObjectInspectorFactory.writableIntObjectInspector;
     ObjectInspector valueOI2 = PrimitiveObjectInspectorFactory.writableDoubleObjectInspector;
-    ObjectInspector[] arguments = { valueOI1, valueOI2 };
-
-    UDFArgumentException ex = null;
-    try {
-      udf.initialize(arguments);
-    } catch (UDFArgumentException e) {
-      ex = e;
-    }
-    assertNotNull("greatest() test ", ex);
+    ObjectInspector valueOI3 = PrimitiveObjectInspectorFactory.writableDateObjectInspector;
+    ObjectInspector valueOI4 = PrimitiveObjectInspectorFactory.writableStringObjectInspector;
+    ObjectInspector[] arguments = { valueOI1, valueOI2, valueOI3, valueOI4 };
+    udf.initialize(arguments);
+    runAndVerify(new Object[] { 1, 11.1, Date.valueOf("2015-03-20"), "test"}, "test", udf);  //string comparisons
   }
 
+
   public void testGreatestStr() throws HiveException {
     GenericUDFGreatest udf = new GenericUDFGreatest();
     ObjectInspector[] arguments = new ObjectInspector[3];
@@ -84,12 +92,12 @@ public void testGreatestStr() throws HiveException {
     runAndVerify(new String[] { "01", "03", "02" }, "03", udf);
     runAndVerify(new String[] { "01", "1", "02" }, "1", udf);
 
-    runAndVerify(new String[] { null, "b", "c" }, "c", udf);
-    runAndVerify(new String[] { "a", null, "c" }, "c", udf);
-    runAndVerify(new String[] { "a", "b", null }, "b", udf);
+    runAndVerify(new String[] { null, "b", "c" }, null, udf);
+    runAndVerify(new String[] { "a", null, "c" }, null, udf);
+    runAndVerify(new String[] { "a", "b", null }, null, udf);
 
-    runAndVerify(new String[] { "a", null, null }, "a", udf);
-    runAndVerify(new String[] { null, "b", null }, "b", udf);
+    runAndVerify(new String[] { "a", null, null }, null, udf);
+    runAndVerify(new String[] { null, "b", null }, null, udf);
     runAndVerify(new String[] { null, null, null }, null, udf);
   }
 
@@ -108,9 +116,9 @@ public void testGreatestInt() throws HiveException {
     runAndVerify(new Integer[] { -11, -13, -12 }, -11, udf);
     runAndVerify(new Integer[] { 1, -13, 2 }, 2, udf);
 
-    runAndVerify(new Integer[] { null, 1, 2 }, 2, udf);
-    runAndVerify(new Integer[] { 1, null, 2 }, 2, udf);
-    runAndVerify(new Integer[] { 1, 2, null }, 2, udf);
+    runAndVerify(new Integer[] { null, 1, 2 }, null, udf);
+    runAndVerify(new Integer[] { 1, null, 2 }, null, udf);
+    runAndVerify(new Integer[] { 1, 2, null }, null, udf);
 
     runAndVerify(new Integer[] { null, null, null }, null, udf);
   }
@@ -130,9 +138,9 @@ public void testGreatestDouble() throws HiveException {
     runAndVerify(new Double[] { -11.4, -13.1, -12.2 }, -11.4, udf);
     runAndVerify(new Double[] { 1.0, -13.3, 2.2 }, 2.2, udf);
 
-    runAndVerify(new Double[] { null, 1.1, 2.2 }, 2.2, udf);
-    runAndVerify(new Double[] { 1.1, null, 2.2 }, 2.2, udf);
-    runAndVerify(new Double[] { 1.1, 2.2, null }, 2.2, udf);
+    runAndVerify(new Double[] { null, 1.1, 2.2 }, null, udf);
+    runAndVerify(new Double[] { 1.1, null, 2.2 }, null, udf);
+    runAndVerify(new Double[] { 1.1, 2.2, null }, null, udf);
 
     runAndVerify(new Double[] { null, null, null }, null, udf);
   }
@@ -152,49 +160,86 @@ public void testGreatestDate() throws HiveException {
 
     runAndVerify(new Date[] { d1, d2, d3 }, d2, udf);
 
-    runAndVerify(new Date[] { null, d2, d3 }, d2, udf);
-    runAndVerify(new Date[] { d1, null, d3 }, d1, udf);
-    runAndVerify(new Date[] { d1, d2, null }, d2, udf);
+    runAndVerify(new Date[] { null, d2, d3 }, null, udf);
+    runAndVerify(new Date[] { d1, null, d3 }, null, udf);
+    runAndVerify(new Date[] { d1, d2, null }, null, udf);
 
     runAndVerify(new Date[] { null, null, null }, null, udf);
   }
 
-  private void runAndVerify(String[] v, String expResult, GenericUDF udf) throws HiveException {
-    DeferredObject[] args = new DeferredObject[v.length];
-    for (int i = 0; i < v.length; i++) {
-      args[i] = new DeferredJavaObject(v[i] != null ? new Text(v[i]) : null);
-    }
-    Text output = (Text) udf.evaluate(args);
-    assertEquals("greatest() test ", expResult, output != null ? output.toString() : null);
+  public void testGreatestIntTypes() throws HiveException {
+    GenericUDFGreatest udf = new GenericUDFGreatest();
+    ObjectInspector[] arguments = new ObjectInspector[4];
+
+    arguments[0] = PrimitiveObjectInspectorFactory.writableByteObjectInspector;
+    arguments[1] = PrimitiveObjectInspectorFactory.writableShortObjectInspector;
+    arguments[2] = PrimitiveObjectInspectorFactory.writableIntObjectInspector;
+    arguments[3] = PrimitiveObjectInspectorFactory.writableLongObjectInspector;
+
+
+    udf.initialize(arguments);
+
+    runAndVerify(new Object[] { (byte) 11, (short) 13, 12, 14L }, 14L, udf);
+    runAndVerify(new Object[] { (byte) 1, (short) 13, 2, 0L }, 13L, udf);
+
+    runAndVerify(new Object[] { (byte) -11, (short) -13, -12, 0L }, 0L, udf);
+    runAndVerify(new Object[] { (byte) 1, (short) -13, 2, 0L}, 2L, udf);
+
+    runAndVerify(new Object[] { null, (short) 1, 2, 0L }, null, udf);
+    runAndVerify(new Object[] { (byte) 1, null, 2, -1L }, null, udf);
+    runAndVerify(new Object[] { (byte) 1, (short) 2, null, -1L }, null, udf);
+
+    runAndVerify(new Integer[] { null, null, null, null }, null, udf);
   }
 
-  private void runAndVerify(Integer[] v, Integer expResult, GenericUDF udf) throws HiveException {
+  private void runAndVerify(Object[] v, Object expResult, GenericUDF udf) throws HiveException {
     DeferredObject[] args = new DeferredObject[v.length];
     for (int i = 0; i < v.length; i++) {
-      args[i] = new DeferredJavaObject(v[i] != null ? new IntWritable(v[i]) : null);
+      args[i] = new DeferredJavaObject(getWritable(v[i]));
     }
-    IntWritable output = (IntWritable) udf.evaluate(args);
-    Integer res = output != null ? Integer.valueOf(output.get()) : null;
-    assertEquals("greatest() test ", expResult, res);
+    Object output = udf.evaluate(args);
+    output = parseOutput(output);
+    assertEquals("greatest() test ", expResult, output != null ? output : null);
   }
 
-  private void runAndVerify(Double[] v, Double expResult, GenericUDF udf) throws HiveException {
-    DeferredObject[] args = new DeferredObject[v.length];
-    for (int i = 0; i < v.length; i++) {
-      args[i] = new DeferredJavaObject(v[i] != null ? new DoubleWritable(v[i]) : null);
+  private Object getWritable(Object o) {
+    if (o instanceof String) {
+      return o != null ? new Text((String) o) : null;
+    } else if (o instanceof Integer) {
+      return o != null ? new IntWritable((Integer) o) : null;
+    } else if (o instanceof Double) {
+      return o != null ? new DoubleWritable((Double) o) : null;
+    } else if (o instanceof Date) {
+      return o != null ? new DateWritable((Date) o) : null;
+    } else if (o instanceof Byte) {
+      return o != null ? new ByteWritable((Byte) o): null;
+    } else if (o instanceof Short) {
+      return o != null ? new ShortWritable((Short) o) : null;
+    } else if (o instanceof Long) {
+      return o != null ? new LongWritable((Long) o) : null;
     }
-    DoubleWritable output = (DoubleWritable) udf.evaluate(args);
-    Double res = output != null ? Double.valueOf(output.get()) : null;
-    assertEquals("greatest() test ", expResult, res);
+    return null;
   }
 
-  private void runAndVerify(Date[] v, Date expResult, GenericUDF udf) throws HiveException {
-    DeferredObject[] args = new DeferredObject[v.length];
-    for (int i = 0; i < v.length; i++) {
-      args[i] = new DeferredJavaObject(v[i] != null ? new DateWritable(v[i]) : null);
+  private Object parseOutput(Object o) {
+    if (o == null) {
+      return null;
+    }
+    if (o instanceof Text) {
+      return o.toString();
+    } else if (o instanceof IntWritable) {
+      return ((IntWritable) o).get();
+    } else if (o instanceof DoubleWritable) {
+      return ((DoubleWritable) o).get();
+    } else if (o instanceof DateWritable) {
+      return ((DateWritable) o).get();
+    } else if (o instanceof ByteWritable) {
+      return ((ByteWritable) o).get();
+    } else if (o instanceof ShortWritable) {
+      return ((ShortWritable) o).get();
+    } else if (o instanceof LongWritable) {
+      return ((LongWritable) o).get();
     }
-    DateWritable output = (DateWritable) udf.evaluate(args);
-    Date res = output != null ? output.get() : null;
-    assertEquals("greatest() test ", expResult, res);
+    return null;
   }
 }
diff --git a/ql/src/test/org/apache/hadoop/hive/ql/udf/generic/TestGenericUDFLeast.java b/ql/src/test/org/apache/hadoop/hive/ql/udf/generic/TestGenericUDFLeast.java
index 47e4801..847754a 100644
--- a/ql/src/test/org/apache/hadoop/hive/ql/udf/generic/TestGenericUDFLeast.java
+++ b/ql/src/test/org/apache/hadoop/hive/ql/udf/generic/TestGenericUDFLeast.java
@@ -25,11 +25,14 @@
 import org.apache.hadoop.hive.ql.metadata.HiveException;
 import org.apache.hadoop.hive.ql.udf.generic.GenericUDF.DeferredJavaObject;
 import org.apache.hadoop.hive.ql.udf.generic.GenericUDF.DeferredObject;
+import org.apache.hadoop.hive.serde2.io.ByteWritable;
 import org.apache.hadoop.hive.serde2.io.DateWritable;
 import org.apache.hadoop.hive.serde2.io.DoubleWritable;
+import org.apache.hadoop.hive.serde2.io.ShortWritable;
 import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;
 import org.apache.hadoop.hive.serde2.objectinspector.primitive.PrimitiveObjectInspectorFactory;
 import org.apache.hadoop.io.IntWritable;
+import org.apache.hadoop.io.LongWritable;
 import org.apache.hadoop.io.Text;
 
 public class TestGenericUDFLeast extends TestCase {
@@ -49,20 +52,25 @@ public void testOneArg() throws HiveException {
     assertNotNull("least() test ", ex);
   }
 
-  public void testDifferentType() throws HiveException {
-    @SuppressWarnings("resource")
-    GenericUDFLeast udf = new GenericUDFLeast();
+  public void testVoids() throws HiveException {
+    GenericUDFGreatest udf = new GenericUDFGreatest();
+    ObjectInspector valueOI1 = PrimitiveObjectInspectorFactory.writableVoidObjectInspector;
+    ObjectInspector valueOI2 = PrimitiveObjectInspectorFactory.writableIntObjectInspector;
+    ObjectInspector valueOI3 = PrimitiveObjectInspectorFactory.writableStringObjectInspector;
+    ObjectInspector[] arguments = { valueOI1, valueOI2, valueOI3 };
+    udf.initialize(arguments);
+    runAndVerify(new Object[] { null, 1, "test"}, null, udf);
+  }
+
+  public void testLeastTypes() throws HiveException {
+    GenericUDFGreatest udf = new GenericUDFGreatest();
     ObjectInspector valueOI1 = PrimitiveObjectInspectorFactory.writableIntObjectInspector;
     ObjectInspector valueOI2 = PrimitiveObjectInspectorFactory.writableDoubleObjectInspector;
-    ObjectInspector[] arguments = { valueOI1, valueOI2 };
-
-    UDFArgumentException ex = null;
-    try {
-      udf.initialize(arguments);
-    } catch (UDFArgumentException e) {
-      ex = e;
-    }
-    assertNotNull("least() test ", ex);
+    ObjectInspector valueOI3 = PrimitiveObjectInspectorFactory.writableDateObjectInspector;
+    ObjectInspector valueOI4 = PrimitiveObjectInspectorFactory.writableStringObjectInspector;
+    ObjectInspector[] arguments = { valueOI1, valueOI2, valueOI3, valueOI4 };
+    udf.initialize(arguments);
+    runAndVerify(new Object[] { 1, 11.1, Date.valueOf("2015-03-20"), "test"}, "test", udf);  //string comparisons
   }
 
   public void testLeastStr() throws HiveException {
@@ -84,12 +92,12 @@ public void testLeastStr() throws HiveException {
     runAndVerify(new String[] { "01", "03", "02" }, "01", udf);
     runAndVerify(new String[] { "01", "1", "02" }, "01", udf);
 
-    runAndVerify(new String[] { null, "b", "c" }, "b", udf);
-    runAndVerify(new String[] { "a", null, "c" }, "a", udf);
-    runAndVerify(new String[] { "a", "b", null }, "a", udf);
+    runAndVerify(new String[] { null, "b", "c" }, null, udf);
+    runAndVerify(new String[] { "a", null, "c" }, null, udf);
+    runAndVerify(new String[] { "a", "b", null }, null, udf);
 
-    runAndVerify(new String[] { "a", null, null }, "a", udf);
-    runAndVerify(new String[] { null, "b", null }, "b", udf);
+    runAndVerify(new String[] { "a", null, null }, null, udf);
+    runAndVerify(new String[] { null, "b", null }, null, udf);
     runAndVerify(new String[] { null, null, null }, null, udf);
   }
 
@@ -108,9 +116,9 @@ public void testLeastInt() throws HiveException {
     runAndVerify(new Integer[] { -11, -13, -12 }, -13, udf);
     runAndVerify(new Integer[] { 1, -13, 2 }, -13, udf);
 
-    runAndVerify(new Integer[] { null, 1, 2 }, 1, udf);
-    runAndVerify(new Integer[] { 1, null, 2 }, 1, udf);
-    runAndVerify(new Integer[] { 1, 2, null }, 1, udf);
+    runAndVerify(new Integer[] { null, 1, 2 }, null, udf);
+    runAndVerify(new Integer[] { 1, null, 2 }, null, udf);
+    runAndVerify(new Integer[] { 1, 2, null }, null, udf);
 
     runAndVerify(new Integer[] { null, null, null }, null, udf);
   }
@@ -130,9 +138,9 @@ public void testLeastDouble() throws HiveException {
     runAndVerify(new Double[] { -11.4, -13.1, -12.2 }, -13.1, udf);
     runAndVerify(new Double[] { 1.0, -13.3, 2.2 }, -13.3, udf);
 
-    runAndVerify(new Double[] { null, 1.1, 2.2 }, 1.1, udf);
-    runAndVerify(new Double[] { 1.1, null, 2.2 }, 1.1, udf);
-    runAndVerify(new Double[] { 1.1, 2.2, null }, 1.1, udf);
+    runAndVerify(new Double[] { null, 1.1, 2.2 }, null, udf);
+    runAndVerify(new Double[] { 1.1, null, 2.2 }, null, udf);
+    runAndVerify(new Double[] { 1.1, 2.2, null }, null, udf);
 
     runAndVerify(new Double[] { null, null, null }, null, udf);
   }
@@ -152,49 +160,86 @@ public void testLeastDate() throws HiveException {
 
     runAndVerify(new Date[] { d1, d2, d3 }, d3, udf);
 
-    runAndVerify(new Date[] { null, d2, d3 }, d3, udf);
-    runAndVerify(new Date[] { d1, null, d3 }, d3, udf);
-    runAndVerify(new Date[] { d1, d2, null }, d1, udf);
+    runAndVerify(new Date[] { null, d2, d3 }, null, udf);
+    runAndVerify(new Date[] { d1, null, d3 }, null, udf);
+    runAndVerify(new Date[] { d1, d2, null }, null, udf);
 
     runAndVerify(new Date[] { null, null, null }, null, udf);
   }
 
-  private void runAndVerify(String[] v, String expResult, GenericUDF udf) throws HiveException {
-    DeferredObject[] args = new DeferredObject[v.length];
-    for (int i = 0; i < v.length; i++) {
-      args[i] = new DeferredJavaObject(v[i] != null ? new Text(v[i]) : null);
-    }
-    Text output = (Text) udf.evaluate(args);
-    assertEquals("least() test ", expResult, output != null ? output.toString() : null);
+  public void testLeastIntTypes() throws HiveException {
+    GenericUDFLeast udf = new GenericUDFLeast();
+    ObjectInspector[] arguments = new ObjectInspector[4];
+
+    arguments[0] = PrimitiveObjectInspectorFactory.writableByteObjectInspector;
+    arguments[1] = PrimitiveObjectInspectorFactory.writableShortObjectInspector;
+    arguments[2] = PrimitiveObjectInspectorFactory.writableIntObjectInspector;
+    arguments[3] = PrimitiveObjectInspectorFactory.writableLongObjectInspector;
+
+
+    udf.initialize(arguments);
+
+    runAndVerify(new Object[] { (byte) 11, (short) 13, 12, 14L }, 11L, udf);
+    runAndVerify(new Object[] { (byte) 1, (short) 13, 2, 0L }, 0L, udf);
+
+    runAndVerify(new Object[] { (byte) -11, (short) -13, -12, 0L }, -13L, udf);
+    runAndVerify(new Object[] { (byte) 1, (short) -13, 2, 0L}, -13L, udf);
+
+    runAndVerify(new Object[] { null, (short) 1, 2, 0L }, null, udf);
+    runAndVerify(new Object[] { (byte) 1, null, 2, -1L }, null, udf);
+    runAndVerify(new Object[] { (byte) 1, (short) 2, null, -1L }, null, udf);
+
+    runAndVerify(new Integer[] { null, null, null, null }, null, udf);
   }
 
-  private void runAndVerify(Integer[] v, Integer expResult, GenericUDF udf) throws HiveException {
+  private void runAndVerify(Object[] v, Object expResult, GenericUDF udf) throws HiveException {
     DeferredObject[] args = new DeferredObject[v.length];
     for (int i = 0; i < v.length; i++) {
-      args[i] = new DeferredJavaObject(v[i] != null ? new IntWritable(v[i]) : null);
+      args[i] = new DeferredJavaObject(getWritable(v[i]));
     }
-    IntWritable output = (IntWritable) udf.evaluate(args);
-    Integer res = output != null ? Integer.valueOf(output.get()) : null;
-    assertEquals("least() test ", expResult, res);
+    Object output = udf.evaluate(args);
+    output = parseOutput(output);
+    assertEquals("greatest() test ", expResult, output != null ? output : null);
   }
 
-  private void runAndVerify(Double[] v, Double expResult, GenericUDF udf) throws HiveException {
-    DeferredObject[] args = new DeferredObject[v.length];
-    for (int i = 0; i < v.length; i++) {
-      args[i] = new DeferredJavaObject(v[i] != null ? new DoubleWritable(v[i]) : null);
+  private Object getWritable(Object o) {
+    if (o instanceof String) {
+      return o != null ? new Text((String) o) : null;
+    } else if (o instanceof Integer) {
+      return o != null ? new IntWritable((Integer) o) : null;
+    } else if (o instanceof Double) {
+      return o != null ? new DoubleWritable((Double) o) : null;
+    } else if (o instanceof Date) {
+      return o != null ? new DateWritable((Date) o) : null;
+    } else if (o instanceof Byte) {
+      return o != null ? new ByteWritable((Byte) o): null;
+    } else if (o instanceof Short) {
+      return o != null ? new ShortWritable((Short) o) : null;
+    } else if (o instanceof Long) {
+      return o != null ? new LongWritable((Long) o) : null;
     }
-    DoubleWritable output = (DoubleWritable) udf.evaluate(args);
-    Double res = output != null ? Double.valueOf(output.get()) : null;
-    assertEquals("least() test ", expResult, res);
+    return null;
   }
 
-  private void runAndVerify(Date[] v, Date expResult, GenericUDF udf) throws HiveException {
-    DeferredObject[] args = new DeferredObject[v.length];
-    for (int i = 0; i < v.length; i++) {
-      args[i] = new DeferredJavaObject(v[i] != null ? new DateWritable(v[i]) : null);
+  private Object parseOutput(Object o) {
+    if (o == null) {
+      return null;
+    }
+    if (o instanceof Text) {
+      return o.toString();
+    } else if (o instanceof IntWritable) {
+      return ((IntWritable) o).get();
+    } else if (o instanceof DoubleWritable) {
+      return ((DoubleWritable) o).get();
+    } else if (o instanceof DateWritable) {
+      return ((DateWritable) o).get();
+    } else if (o instanceof ByteWritable) {
+      return ((ByteWritable) o).get();
+    } else if (o instanceof ShortWritable) {
+      return ((ShortWritable) o).get();
+    } else if (o instanceof LongWritable) {
+      return ((LongWritable) o).get();
     }
-    DateWritable output = (DateWritable) udf.evaluate(args);
-    Date res = output != null ? output.get() : null;
-    assertEquals("least() test ", expResult, res);
+    return null;
   }
 }
diff --git a/ql/src/test/queries/clientnegative/udf_greatest_error_2.q b/ql/src/test/queries/clientnegative/udf_greatest_error_2.q
index b270a1a..ae6d928 100644
--- a/ql/src/test/queries/clientnegative/udf_greatest_error_2.q
+++ b/ql/src/test/queries/clientnegative/udf_greatest_error_2.q
@@ -1 +1 @@
-SELECT GREATEST(1, 2.2) FROM src LIMIT 1;
+SELECT GREATEST(1) FROM src LIMIT 1;
diff --git a/ql/src/test/queries/clientnegative/udf_greatest_error_3.q b/ql/src/test/queries/clientnegative/udf_greatest_error_3.q
deleted file mode 100644
index ba21748..0000000
--- a/ql/src/test/queries/clientnegative/udf_greatest_error_3.q
+++ /dev/null
@@ -1 +0,0 @@
-SELECT GREATEST(1, '2') FROM src LIMIT 1;
diff --git a/ql/src/test/queries/clientnegative/udf_greatest_error_4.q b/ql/src/test/queries/clientnegative/udf_greatest_error_4.q
deleted file mode 100644
index ae6d928..0000000
--- a/ql/src/test/queries/clientnegative/udf_greatest_error_4.q
+++ /dev/null
@@ -1 +0,0 @@
-SELECT GREATEST(1) FROM src LIMIT 1;
diff --git a/ql/src/test/queries/clientpositive/udf_greatest.q b/ql/src/test/queries/clientpositive/udf_greatest.q
index 02c7d3c..03c01b5 100644
--- a/ql/src/test/queries/clientpositive/udf_greatest.q
+++ b/ql/src/test/queries/clientpositive/udf_greatest.q
@@ -55,3 +55,23 @@ SELECT GREATEST(11.4, 13.5, 12.2),
        GREATEST(1.1, 2.2, null),
        GREATEST(cast(null as double), null, null)
 FROM src tablesample (1 rows);
+
+SELECT GREATEST(101Y, -101S, 100, -100L, null),
+       GREATEST(-101Y, 101S, 100, -100L, 0),
+       GREATEST(100Y, -100S, 101, -101L, null),
+       GREATEST(100Y, -100S, -101, 101L, 0)
+FROM src tablesample (1 rows);
+
+SELECT GREATEST(cast(1.1 as float), cast(-1.1 as double), cast(0.5 as decimal)),
+       GREATEST(cast(-1.1 as float), cast(1.1 as double), cast(0.5 as decimal)),
+       GREATEST(cast(0.1 as float), cast(-0.1 as double), cast(0.5 as decimal)),
+       GREATEST(null, cast(-0.1 as double), cast(0.5 as decimal))
+FROM src tablesample (1 rows);
+
+SELECT GREATEST(-100Y, -80S, -60, -40L, cast(-20 as float), cast(0 as double), cast(0.5 as decimal)),
+       GREATEST(100Y, 80S, 60, 40L, cast(20 as float), cast(0 as double), cast(-0.5 as decimal)),
+       GREATEST(100Y, 80S, 60, 40L, null, cast(0 as double), cast(-0.5 as decimal))
+FROM src tablesample (1 rows);
+
+SELECT GREATEST(10L, 'a', date('2001-01-28'))
+FROM src tablesample (1 rows);
\ No newline at end of file
diff --git a/ql/src/test/queries/clientpositive/udf_least.q b/ql/src/test/queries/clientpositive/udf_least.q
index a754ef0..93d0ee8 100644
--- a/ql/src/test/queries/clientpositive/udf_least.q
+++ b/ql/src/test/queries/clientpositive/udf_least.q
@@ -55,3 +55,23 @@ SELECT LEAST(11.4, 13.5, 12.2),
        LEAST(1.1, 2.2, null),
        LEAST(cast(null as double), null, null)
 FROM src tablesample (1 rows);
+
+SELECT LEAST(101Y, -101S, 100, -100L, null),
+       LEAST(-101Y, 101S, 100, -100L, 0),
+       LEAST(100Y, -100S, 101, -101L, null),
+       LEAST(100Y, -100S, -101, 101L, 0)
+FROM src tablesample (1 rows);
+
+SELECT LEAST(cast(1.1 as float), cast(-1.1 as double), cast(0.5 as decimal)),
+       LEAST(cast(-1.1 as float), cast(1.1 as double), cast(0.5 as decimal)),
+       LEAST(cast(0.1 as float), cast(-0.1 as double), cast(0.5 as decimal)),
+       LEAST(null, cast(-0.1 as double), cast(0.5 as decimal))
+FROM src tablesample (1 rows);
+
+SELECT LEAST(-100Y, -80S, -60, -40L, cast(-20 as float), cast(0 as double), cast(0.5 as decimal)),
+       LEAST(100Y, 80S, 60, 40L, cast(20 as float), cast(0 as double), cast(-0.5 as decimal)),
+       LEAST(100Y, 80S, 60, 40L, null, cast(0 as double), cast(-0.5 as decimal))
+FROM src tablesample (1 rows);
+
+SELECT LEAST(10L, 'a', date('2001-01-28'))
+FROM src tablesample (1 rows);
\ No newline at end of file
diff --git a/ql/src/test/results/clientnegative/udf_greatest_error_2.q.out b/ql/src/test/results/clientnegative/udf_greatest_error_2.q.out
index 9a6348c..58b4c44 100644
--- a/ql/src/test/results/clientnegative/udf_greatest_error_2.q.out
+++ b/ql/src/test/results/clientnegative/udf_greatest_error_2.q.out
@@ -1 +1 @@
-FAILED: SemanticException [Error 10016]: Line 1:19 Argument type mismatch '2.2': The expressions after greatest should all have the same type: "int" is expected but "double" is found
+FAILED: SemanticException [Error 10015]: Line 1:7 Arguments length mismatch '1': greatest requires at least 2 arguments, got 1
diff --git a/ql/src/test/results/clientnegative/udf_greatest_error_3.q.out b/ql/src/test/results/clientnegative/udf_greatest_error_3.q.out
deleted file mode 100644
index 3fb3499..0000000
--- a/ql/src/test/results/clientnegative/udf_greatest_error_3.q.out
+++ /dev/null
@@ -1 +0,0 @@
-FAILED: SemanticException [Error 10016]: Line 1:19 Argument type mismatch ''2'': The expressions after greatest should all have the same type: "int" is expected but "string" is found
diff --git a/ql/src/test/results/clientnegative/udf_greatest_error_4.q.out b/ql/src/test/results/clientnegative/udf_greatest_error_4.q.out
deleted file mode 100644
index 58b4c44..0000000
--- a/ql/src/test/results/clientnegative/udf_greatest_error_4.q.out
+++ /dev/null
@@ -1 +0,0 @@
-FAILED: SemanticException [Error 10015]: Line 1:7 Arguments length mismatch '1': greatest requires at least 2 arguments, got 1
diff --git a/ql/src/test/results/clientpositive/udf_greatest.q.out b/ql/src/test/results/clientpositive/udf_greatest.q.out
index 10f1c2d..47cfb3f 100644
--- a/ql/src/test/results/clientpositive/udf_greatest.q.out
+++ b/ql/src/test/results/clientpositive/udf_greatest.q.out
@@ -58,9 +58,9 @@ STAGE PLANS:
           Row Limit Per Split: 1
           Statistics: Num rows: 500 Data size: 5312 Basic stats: COMPLETE Column stats: COMPLETE
           Select Operator
-            expressions: 'c' (type: string), 'a' (type: string), 'AaA' (type: string), 'AAA' (type: string), '13' (type: string), '2' (type: string), '03' (type: string), '1' (type: string), 'c' (type: string), 'c' (type: string), 'b' (type: string), 'a' (type: string), 'b' (type: string), null (type: string)
+            expressions: 'c' (type: string), 'a' (type: string), 'AaA' (type: string), 'AAA' (type: string), '13' (type: string), '2' (type: string), '03' (type: string), '1' (type: string), null (type: double), null (type: double), null (type: double), null (type: double), null (type: double), null (type: double)
             outputColumnNames: _col0, _col1, _col2, _col3, _col4, _col5, _col6, _col7, _col8, _col9, _col10, _col11, _col12, _col13
-            Statistics: Num rows: 500 Data size: 555500 Basic stats: COMPLETE Column stats: COMPLETE
+            Statistics: Num rows: 500 Data size: 343000 Basic stats: COMPLETE Column stats: COMPLETE
             ListSink
 
 PREHOOK: query: SELECT GREATEST('a', 'b', 'c'),
@@ -99,7 +99,7 @@ FROM src tablesample (1 rows)
 POSTHOOK: type: QUERY
 POSTHOOK: Input: default@src
 #### A masked pattern was here ####
-c	a	AaA	AAA	13	2	03	1	c	c	b	a	b	NULL
+c	a	AaA	AAA	13	2	03	1	NULL	NULL	NULL	NULL	NULL	NULL
 PREHOOK: query: SELECT GREATEST(11, 13, 12),
        GREATEST(1, 13, 2),
        GREATEST(-11, -13, -12),
@@ -124,7 +124,7 @@ FROM src tablesample (1 rows)
 POSTHOOK: type: QUERY
 POSTHOOK: Input: default@src
 #### A masked pattern was here ####
-13	13	-11	2	2	2	2	NULL
+13	13	-11	2	NULL	NULL	NULL	NULL
 PREHOOK: query: SELECT GREATEST(11.4, 13.5, 12.2),
        GREATEST(1.0, 13.2, 2.0),
        GREATEST(-11.4, -13.1, -12.2),
@@ -149,4 +149,64 @@ FROM src tablesample (1 rows)
 POSTHOOK: type: QUERY
 POSTHOOK: Input: default@src
 #### A masked pattern was here ####
-13.5	13.2	-11.4	2.2	2.2	2.2	2.2	NULL
+13.5	13.2	-11.4	2.2	NULL	NULL	NULL	NULL
+PREHOOK: query: SELECT GREATEST(101Y, -101S, 100, -100L, null),
+       GREATEST(-101Y, 101S, 100, -100L, 0),
+       GREATEST(100Y, -100S, 101, -101L, null),
+       GREATEST(100Y, -100S, -101, 101L, 0)
+FROM src tablesample (1 rows)
+PREHOOK: type: QUERY
+PREHOOK: Input: default@src
+#### A masked pattern was here ####
+POSTHOOK: query: SELECT GREATEST(101Y, -101S, 100, -100L, null),
+       GREATEST(-101Y, 101S, 100, -100L, 0),
+       GREATEST(100Y, -100S, 101, -101L, null),
+       GREATEST(100Y, -100S, -101, 101L, 0)
+FROM src tablesample (1 rows)
+POSTHOOK: type: QUERY
+POSTHOOK: Input: default@src
+#### A masked pattern was here ####
+NULL	101	NULL	101
+PREHOOK: query: SELECT GREATEST(cast(1.1 as float), cast(-1.1 as double), cast(0.5 as decimal)),
+       GREATEST(cast(-1.1 as float), cast(1.1 as double), cast(0.5 as decimal)),
+       GREATEST(cast(0.1 as float), cast(-0.1 as double), cast(0.5 as decimal)),
+       GREATEST(null, cast(-0.1 as double), cast(0.5 as decimal))
+FROM src tablesample (1 rows)
+PREHOOK: type: QUERY
+PREHOOK: Input: default@src
+#### A masked pattern was here ####
+POSTHOOK: query: SELECT GREATEST(cast(1.1 as float), cast(-1.1 as double), cast(0.5 as decimal)),
+       GREATEST(cast(-1.1 as float), cast(1.1 as double), cast(0.5 as decimal)),
+       GREATEST(cast(0.1 as float), cast(-0.1 as double), cast(0.5 as decimal)),
+       GREATEST(null, cast(-0.1 as double), cast(0.5 as decimal))
+FROM src tablesample (1 rows)
+POSTHOOK: type: QUERY
+POSTHOOK: Input: default@src
+#### A masked pattern was here ####
+1.1	1.1	1	NULL
+PREHOOK: query: SELECT GREATEST(-100Y, -80S, -60, -40L, cast(-20 as float), cast(0 as double), cast(0.5 as decimal)),
+       GREATEST(100Y, 80S, 60, 40L, cast(20 as float), cast(0 as double), cast(-0.5 as decimal)),
+       GREATEST(100Y, 80S, 60, 40L, null, cast(0 as double), cast(-0.5 as decimal))
+FROM src tablesample (1 rows)
+PREHOOK: type: QUERY
+PREHOOK: Input: default@src
+#### A masked pattern was here ####
+POSTHOOK: query: SELECT GREATEST(-100Y, -80S, -60, -40L, cast(-20 as float), cast(0 as double), cast(0.5 as decimal)),
+       GREATEST(100Y, 80S, 60, 40L, cast(20 as float), cast(0 as double), cast(-0.5 as decimal)),
+       GREATEST(100Y, 80S, 60, 40L, null, cast(0 as double), cast(-0.5 as decimal))
+FROM src tablesample (1 rows)
+POSTHOOK: type: QUERY
+POSTHOOK: Input: default@src
+#### A masked pattern was here ####
+1	100	NULL
+PREHOOK: query: SELECT GREATEST(10L, 'a', date('2001-01-28'))
+FROM src tablesample (1 rows)
+PREHOOK: type: QUERY
+PREHOOK: Input: default@src
+#### A masked pattern was here ####
+POSTHOOK: query: SELECT GREATEST(10L, 'a', date('2001-01-28'))
+FROM src tablesample (1 rows)
+POSTHOOK: type: QUERY
+POSTHOOK: Input: default@src
+#### A masked pattern was here ####
+a
diff --git a/ql/src/test/results/clientpositive/udf_least.q.out b/ql/src/test/results/clientpositive/udf_least.q.out
index 6983137..2363abe 100644
--- a/ql/src/test/results/clientpositive/udf_least.q.out
+++ b/ql/src/test/results/clientpositive/udf_least.q.out
@@ -58,9 +58,9 @@ STAGE PLANS:
           Row Limit Per Split: 1
           Statistics: Num rows: 500 Data size: 5312 Basic stats: COMPLETE Column stats: COMPLETE
           Select Operator
-            expressions: 'a' (type: string), 'B' (type: string), 'AAA' (type: string), 'A' (type: string), '11' (type: string), '11' (type: string), '01' (type: string), '01' (type: string), 'b' (type: string), 'a' (type: string), 'a' (type: string), 'a' (type: string), 'b' (type: string), null (type: string)
+            expressions: 'a' (type: string), 'B' (type: string), 'AAA' (type: string), 'A' (type: string), '11' (type: string), '11' (type: string), '01' (type: string), '01' (type: string), null (type: double), null (type: double), null (type: double), null (type: double), null (type: double), null (type: double)
             outputColumnNames: _col0, _col1, _col2, _col3, _col4, _col5, _col6, _col7, _col8, _col9, _col10, _col11, _col12, _col13
-            Statistics: Num rows: 500 Data size: 555500 Basic stats: COMPLETE Column stats: COMPLETE
+            Statistics: Num rows: 500 Data size: 343000 Basic stats: COMPLETE Column stats: COMPLETE
             ListSink
 
 PREHOOK: query: SELECT LEAST('a', 'b', 'c'),
@@ -99,7 +99,7 @@ FROM src tablesample (1 rows)
 POSTHOOK: type: QUERY
 POSTHOOK: Input: default@src
 #### A masked pattern was here ####
-a	B	AAA	A	11	11	01	01	b	a	a	a	b	NULL
+a	B	AAA	A	11	11	01	01	NULL	NULL	NULL	NULL	NULL	NULL
 PREHOOK: query: SELECT LEAST(11, 13, 12),
        LEAST(1, 13, 2),
        LEAST(-11, -13, -12),
@@ -124,7 +124,7 @@ FROM src tablesample (1 rows)
 POSTHOOK: type: QUERY
 POSTHOOK: Input: default@src
 #### A masked pattern was here ####
-11	1	-13	-13	1	1	1	NULL
+11	1	-13	-13	NULL	NULL	NULL	NULL
 PREHOOK: query: SELECT LEAST(11.4, 13.5, 12.2),
        LEAST(1.0, 13.2, 2.0),
        LEAST(-11.4, -13.1, -12.2),
@@ -149,4 +149,64 @@ FROM src tablesample (1 rows)
 POSTHOOK: type: QUERY
 POSTHOOK: Input: default@src
 #### A masked pattern was here ####
-11.4	1.0	-13.1	-13.3	1.1	1.1	1.1	NULL
+11.4	1.0	-13.1	-13.3	NULL	NULL	NULL	NULL
+PREHOOK: query: SELECT LEAST(101Y, -101S, 100, -100L, null),
+       LEAST(-101Y, 101S, 100, -100L, 0),
+       LEAST(100Y, -100S, 101, -101L, null),
+       LEAST(100Y, -100S, -101, 101L, 0)
+FROM src tablesample (1 rows)
+PREHOOK: type: QUERY
+PREHOOK: Input: default@src
+#### A masked pattern was here ####
+POSTHOOK: query: SELECT LEAST(101Y, -101S, 100, -100L, null),
+       LEAST(-101Y, 101S, 100, -100L, 0),
+       LEAST(100Y, -100S, 101, -101L, null),
+       LEAST(100Y, -100S, -101, 101L, 0)
+FROM src tablesample (1 rows)
+POSTHOOK: type: QUERY
+POSTHOOK: Input: default@src
+#### A masked pattern was here ####
+NULL	-101	NULL	-101
+PREHOOK: query: SELECT LEAST(cast(1.1 as float), cast(-1.1 as double), cast(0.5 as decimal)),
+       LEAST(cast(-1.1 as float), cast(1.1 as double), cast(0.5 as decimal)),
+       LEAST(cast(0.1 as float), cast(-0.1 as double), cast(0.5 as decimal)),
+       LEAST(null, cast(-0.1 as double), cast(0.5 as decimal))
+FROM src tablesample (1 rows)
+PREHOOK: type: QUERY
+PREHOOK: Input: default@src
+#### A masked pattern was here ####
+POSTHOOK: query: SELECT LEAST(cast(1.1 as float), cast(-1.1 as double), cast(0.5 as decimal)),
+       LEAST(cast(-1.1 as float), cast(1.1 as double), cast(0.5 as decimal)),
+       LEAST(cast(0.1 as float), cast(-0.1 as double), cast(0.5 as decimal)),
+       LEAST(null, cast(-0.1 as double), cast(0.5 as decimal))
+FROM src tablesample (1 rows)
+POSTHOOK: type: QUERY
+POSTHOOK: Input: default@src
+#### A masked pattern was here ####
+-1.1	-1.1	-0.1	NULL
+PREHOOK: query: SELECT LEAST(-100Y, -80S, -60, -40L, cast(-20 as float), cast(0 as double), cast(0.5 as decimal)),
+       LEAST(100Y, 80S, 60, 40L, cast(20 as float), cast(0 as double), cast(-0.5 as decimal)),
+       LEAST(100Y, 80S, 60, 40L, null, cast(0 as double), cast(-0.5 as decimal))
+FROM src tablesample (1 rows)
+PREHOOK: type: QUERY
+PREHOOK: Input: default@src
+#### A masked pattern was here ####
+POSTHOOK: query: SELECT LEAST(-100Y, -80S, -60, -40L, cast(-20 as float), cast(0 as double), cast(0.5 as decimal)),
+       LEAST(100Y, 80S, 60, 40L, cast(20 as float), cast(0 as double), cast(-0.5 as decimal)),
+       LEAST(100Y, 80S, 60, 40L, null, cast(0 as double), cast(-0.5 as decimal))
+FROM src tablesample (1 rows)
+POSTHOOK: type: QUERY
+POSTHOOK: Input: default@src
+#### A masked pattern was here ####
+-100	-1	NULL
+PREHOOK: query: SELECT LEAST(10L, 'a', date('2001-01-28'))
+FROM src tablesample (1 rows)
+PREHOOK: type: QUERY
+PREHOOK: Input: default@src
+#### A masked pattern was here ####
+POSTHOOK: query: SELECT LEAST(10L, 'a', date('2001-01-28'))
+FROM src tablesample (1 rows)
+POSTHOOK: type: QUERY
+POSTHOOK: Input: default@src
+#### A masked pattern was here ####
+10
-- 
1.7.9.5

