From 3b1de374ddb047baf9900476b45539e0d4026173 Mon Sep 17 00:00:00 2001
From: Peter Vary <pvary@cloudera.com>
Date: Fri, 26 May 2017 13:17:59 +0200
Subject: [PATCH 1154/1164] CDH-54352 CVE-2016-3083: Apache Hive SSL
 vulnerability bug disclosure           Upstream
 solved by HIVE-13390 (unrelated patch)          
 Partial backport, only the relevant parts.       
    Needed httpclient 4.5.2 and httpcore 4.4.4.   
        Do not want to upgrade libs, so added
 relevant files from source

Change-Id: I1aa500ac577b7496a382e7a88a0b68c53d42217e
(cherry picked from commit 5f908e7c65d21455f34e549f8b1d3fb69538c28c)
---
 .../test/java/org/apache/hive/jdbc/TestSSL.java    |   49 +++
 .../java/org/apache/hive/jdbc/HiveConnection.java  |    3 +-
 .../http/conn_452/ssl/DefaultHostnameVerifier.java |  341 ++++++++++++++++++++
 .../org/apache/http/conn_452/util/DomainType.java  |   38 +++
 .../http/conn_452/util/InetAddressUtils.java       |  124 +++++++
 .../http/conn_452/util/PublicSuffixList.java       |   79 +++++
 .../http/conn_452/util/PublicSuffixMatcher.java    |  202 ++++++++++++
 jdbc/src/java/org/apache/http/util_444/Args.java   |  127 ++++++++
 .../java/org/apache/http/util_444/TextUtils.java   |   75 +++++
 9 files changed, 1037 insertions(+), 1 deletion(-)
 create mode 100644 jdbc/src/java/org/apache/http/conn_452/ssl/DefaultHostnameVerifier.java
 create mode 100644 jdbc/src/java/org/apache/http/conn_452/util/DomainType.java
 create mode 100644 jdbc/src/java/org/apache/http/conn_452/util/InetAddressUtils.java
 create mode 100644 jdbc/src/java/org/apache/http/conn_452/util/PublicSuffixList.java
 create mode 100644 jdbc/src/java/org/apache/http/conn_452/util/PublicSuffixMatcher.java
 create mode 100644 jdbc/src/java/org/apache/http/util_444/Args.java
 create mode 100644 jdbc/src/java/org/apache/http/util_444/TextUtils.java

diff --git a/itests/hive-unit/src/test/java/org/apache/hive/jdbc/TestSSL.java b/itests/hive-unit/src/test/java/org/apache/hive/jdbc/TestSSL.java
index 993c94c..9b3523f 100644
--- a/itests/hive-unit/src/test/java/org/apache/hive/jdbc/TestSSL.java
+++ b/itests/hive-unit/src/test/java/org/apache/hive/jdbc/TestSSL.java
@@ -384,6 +384,55 @@ public void testSSLFetchHttp() throws Exception {
     hs2Conn.close();
   }
 
+  /***
+   * Test a new connection when server sends a certificate with wrong CN
+   * (sends a certificate for www.example.com instead of localhost)
+   * Opening a new connection with this wrong certificate should fail
+   * @throws Exception
+   */
+  @Test
+  public void testConnectionWrongCertCN() throws Exception {
+    // This call sets the default ssl params including the correct keystore in the server config
+    setSslConfOverlay(confOverlay);
+    // Replace default keystore with keystore for www.example.com
+    confOverlay.put(ConfVars.HIVE_SERVER2_SSL_KEYSTORE_PATH.varname, dataFileDir + File.separator
+        + EXAMPLEDOTCOM_KEY_STORE_NAME);
+    // Binary (TCP) mode
+    setBinaryConfOverlay(confOverlay);
+    miniHS2.start(confOverlay);
+    try {
+      hs2Conn =
+          DriverManager.getConnection(miniHS2.getJdbcURL("default", SSL_CONN_PARAMS),
+              System.getProperty("user.name"), "bar");
+      fail("SSL connection, with the server providing wrong certifcate (with CN www.example.com, "
+          + "instead of localhost), should fail");
+    } catch (SQLException e) {
+      // Expected error: should throw java.security.cert.CertificateException
+      assertEquals("08S01", e.getSQLState().trim());
+      assertTrue(e.toString().contains("java.security.cert.CertificateException"));
+    }
+
+    miniHS2.stop();
+
+    // Http mode
+    setHttpConfOverlay(confOverlay);
+    miniHS2.start(confOverlay);
+    try {
+      hs2Conn =
+          DriverManager.getConnection(miniHS2.getJdbcURL("default", SSL_CONN_PARAMS),
+              System.getProperty("user.name"), "bar");
+      fail("SSL connection, with the server providing wrong certifcate (with CN www.example.com, "
+          + "instead of localhost), should fail");
+    } catch (SQLException e) {
+      // Expected error: should throw javax.net.ssl.SSLPeerUnverifiedException
+      assertEquals("08S01", e.getSQLState().trim());
+      assertTrue(e.toString().contains("javax.net.ssl.SSLException: Certificate for"));
+    }
+    // Revert to default keystore path
+    confOverlay.put(ConfVars.HIVE_SERVER2_SSL_KEYSTORE_PATH.varname, dataFileDir + File.separator
+        + LOCALHOST_KEY_STORE_NAME);
+  }
+
   /**
    * Test HMS server with SSL
    * @throws Exception
diff --git a/jdbc/src/java/org/apache/hive/jdbc/HiveConnection.java b/jdbc/src/java/org/apache/hive/jdbc/HiveConnection.java
index b03f690..1d5d785 100644
--- a/jdbc/src/java/org/apache/hive/jdbc/HiveConnection.java
+++ b/jdbc/src/java/org/apache/hive/jdbc/HiveConnection.java
@@ -26,6 +26,7 @@
 import org.apache.hive.service.auth.SaslQOP;
 import org.apache.hive.service.cli.thrift.EmbeddedThriftBinaryCLIService;
 import org.apache.http.HttpRequestInterceptor;
+import org.apache.http.conn_452.ssl.DefaultHostnameVerifier;
 import org.apache.thrift.TException;
 import org.apache.thrift.protocol.TBinaryProtocol;
 import org.apache.thrift.transport.THttpClient;
@@ -331,7 +332,7 @@ private DefaultHttpClient getHttpClient(Boolean useSsl) throws SQLException {
               sslTrustStorePassword.toCharArray());
           socketFactory = new SSLSocketFactory(sslTrustStore);
         }
-        socketFactory.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
+        socketFactory.setHostnameVerifier(new DefaultHostnameVerifier());
         Scheme sslScheme = new Scheme("https", 443, socketFactory);
         httpClient.getConnectionManager().getSchemeRegistry().register(sslScheme);
       }
diff --git a/jdbc/src/java/org/apache/http/conn_452/ssl/DefaultHostnameVerifier.java b/jdbc/src/java/org/apache/http/conn_452/ssl/DefaultHostnameVerifier.java
new file mode 100644
index 0000000..2c5e848
--- /dev/null
+++ b/jdbc/src/java/org/apache/http/conn_452/ssl/DefaultHostnameVerifier.java
@@ -0,0 +1,341 @@
+/*
+ * ====================================================================
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ *
+ */
+
+package org.apache.http.conn_452.ssl;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.security.cert.Certificate;
+import java.security.cert.CertificateParsingException;
+import java.security.cert.X509Certificate;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.Locale;
+import java.util.NoSuchElementException;
+
+import javax.naming.InvalidNameException;
+import javax.naming.NamingException;
+import javax.naming.directory.Attribute;
+import javax.naming.directory.Attributes;
+import javax.naming.ldap.LdapName;
+import javax.naming.ldap.Rdn;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.SSLException;
+import javax.net.ssl.SSLSession;
+import javax.net.ssl.SSLSocket;
+import javax.security.auth.x500.X500Principal;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.http.annotation.Immutable;
+import org.apache.http.conn.ssl.X509HostnameVerifier;
+import org.apache.http.conn_452.util.DomainType;
+import org.apache.http.conn_452.util.InetAddressUtils;
+import org.apache.http.conn_452.util.PublicSuffixMatcher;
+
+/**
+ * Default {@link javax.net.ssl.HostnameVerifier} implementation.
+ *
+ * @since 4.4
+ */
+@Immutable
+public final class DefaultHostnameVerifier implements HostnameVerifier, X509HostnameVerifier {
+
+  enum TYPE { IPv4, IPv6, DNS };
+
+  final static int DNS_NAME_TYPE        = 2;
+  final static int IP_ADDRESS_TYPE      = 7;
+
+  private final Log log = LogFactory.getLog(getClass());
+
+  private final PublicSuffixMatcher publicSuffixMatcher;
+
+  public DefaultHostnameVerifier(final PublicSuffixMatcher publicSuffixMatcher) {
+    this.publicSuffixMatcher = publicSuffixMatcher;
+  }
+
+  public DefaultHostnameVerifier() {
+    this(null);
+  }
+
+  @Override
+  public boolean verify(final String host, final SSLSession session) {
+    try {
+      final Certificate[] certs = session.getPeerCertificates();
+      final X509Certificate x509 = (X509Certificate) certs[0];
+      verify(host, x509);
+      return true;
+    } catch (final SSLException ex) {
+      if (log.isDebugEnabled()) {
+        log.debug(ex.getMessage(), ex);
+      }
+      return false;
+    }
+  }
+
+  public void verify(final String host, final X509Certificate cert) throws SSLException {
+    TYPE hostFormat = TYPE.DNS;
+    if (InetAddressUtils.isIPv4Address(host)) {
+      hostFormat = TYPE.IPv4;
+    } else {
+      String s = host;
+      if (s.startsWith("[") && s.endsWith("]")) {
+        s = host.substring(1, host.length() - 1);
+      }
+      if (InetAddressUtils.isIPv6Address(s)) {
+        hostFormat = TYPE.IPv6;
+      }
+    }
+    final int subjectType = hostFormat == TYPE.IPv4 || hostFormat == TYPE.IPv6 ? IP_ADDRESS_TYPE : DNS_NAME_TYPE;
+    final List<String> subjectAlts = extractSubjectAlts(cert, subjectType);
+    if (subjectAlts != null && !subjectAlts.isEmpty()) {
+      switch (hostFormat) {
+        case IPv4:
+          matchIPAddress(host, subjectAlts);
+          break;
+        case IPv6:
+          matchIPv6Address(host, subjectAlts);
+          break;
+        default:
+          matchDNSName(host, subjectAlts, this.publicSuffixMatcher);
+      }
+    } else {
+      // CN matching has been deprecated by rfc2818 and can be used
+      // as fallback only when no subjectAlts are available
+      final X500Principal subjectPrincipal = cert.getSubjectX500Principal();
+      final String cn = extractCN(subjectPrincipal.getName(X500Principal.RFC2253));
+      if (cn == null) {
+        throw new SSLException("Certificate subject for <" + host + "> doesn't contain " +
+                                   "a common name and does not have alternative names");
+      }
+      matchCN(host, cn, this.publicSuffixMatcher);
+    }
+  }
+
+  static void matchIPAddress(final String host, final List<String> subjectAlts) throws SSLException {
+    for (int i = 0; i < subjectAlts.size(); i++) {
+      final String subjectAlt = subjectAlts.get(i);
+      if (host.equals(subjectAlt)) {
+        return;
+      }
+    }
+    throw new SSLException("Certificate for <" + host + "> doesn't match any " +
+                               "of the subject alternative names: " + subjectAlts);
+  }
+
+  static void matchIPv6Address(final String host, final List<String> subjectAlts) throws SSLException {
+    final String normalisedHost = normaliseAddress(host);
+    for (int i = 0; i < subjectAlts.size(); i++) {
+      final String subjectAlt = subjectAlts.get(i);
+      final String normalizedSubjectAlt = normaliseAddress(subjectAlt);
+      if (normalisedHost.equals(normalizedSubjectAlt)) {
+        return;
+      }
+    }
+    throw new SSLException("Certificate for <" + host + "> doesn't match any " +
+                               "of the subject alternative names: " + subjectAlts);
+  }
+
+  static void matchDNSName(final String host, final List<String> subjectAlts,
+                           final PublicSuffixMatcher publicSuffixMatcher) throws SSLException {
+    final String normalizedHost = host.toLowerCase(Locale.ROOT);
+    for (int i = 0; i < subjectAlts.size(); i++) {
+      final String subjectAlt = subjectAlts.get(i);
+      final String normalizedSubjectAlt = subjectAlt.toLowerCase(Locale.ROOT);
+      if (matchIdentityStrict(normalizedHost, normalizedSubjectAlt, publicSuffixMatcher)) {
+        return;
+      }
+    }
+    throw new SSLException("Certificate for <" + host + "> doesn't match any " +
+                               "of the subject alternative names: " + subjectAlts);
+  }
+
+  static void matchCN(final String host, final String cn,
+                      final PublicSuffixMatcher publicSuffixMatcher) throws SSLException {
+    if (!matchIdentityStrict(host, cn, publicSuffixMatcher)) {
+      throw new SSLException("Certificate for <" + host + "> doesn't match " +
+                                 "common name of the certificate subject: " + cn);
+    }
+  }
+
+  static boolean matchDomainRoot(final String host, final String domainRoot) {
+    if (domainRoot == null) {
+      return false;
+    }
+    return host.endsWith(domainRoot) && (host.length() == domainRoot.length()
+                                             || host.charAt(host.length() - domainRoot.length() - 1) == '.');
+  }
+
+  private static boolean matchIdentity(final String host, final String identity,
+                                       final PublicSuffixMatcher publicSuffixMatcher,
+                                       final boolean strict) {
+    if (publicSuffixMatcher != null && host.contains(".")) {
+      if (!matchDomainRoot(host, publicSuffixMatcher.getDomainRoot(identity, DomainType.ICANN))) {
+        return false;
+      }
+    }
+
+    // RFC 2818, 3.1. Server Identity
+    // "...Names may contain the wildcard
+    // character * which is considered to match any single domain name
+    // component or component fragment..."
+    // Based on this statement presuming only singular wildcard is legal
+    final int asteriskIdx = identity.indexOf('*');
+    if (asteriskIdx != -1) {
+      final String prefix = identity.substring(0, asteriskIdx);
+      final String suffix = identity.substring(asteriskIdx + 1);
+      if (!prefix.isEmpty() && !host.startsWith(prefix)) {
+        return false;
+      }
+      if (!suffix.isEmpty() && !host.endsWith(suffix)) {
+        return false;
+      }
+      // Additional sanity checks on content selected by wildcard can be done here
+      if (strict) {
+        final String remainder = host.substring(
+            prefix.length(), host.length() - suffix.length());
+        if (remainder.contains(".")) {
+          return false;
+        }
+      }
+      return true;
+    }
+    return host.equalsIgnoreCase(identity);
+  }
+
+  static boolean matchIdentity(final String host, final String identity,
+                               final PublicSuffixMatcher publicSuffixMatcher) {
+    return matchIdentity(host, identity, publicSuffixMatcher, false);
+  }
+
+  static boolean matchIdentity(final String host, final String identity) {
+    return matchIdentity(host, identity, null, false);
+  }
+
+  static boolean matchIdentityStrict(final String host, final String identity,
+                                     final PublicSuffixMatcher publicSuffixMatcher) {
+    return matchIdentity(host, identity, publicSuffixMatcher, true);
+  }
+
+  static boolean matchIdentityStrict(final String host, final String identity) {
+    return matchIdentity(host, identity, null, true);
+  }
+
+  static String extractCN(final String subjectPrincipal) throws SSLException {
+    if (subjectPrincipal == null) {
+      return null;
+    }
+    try {
+      final LdapName subjectDN = new LdapName(subjectPrincipal);
+      final List<Rdn> rdns = subjectDN.getRdns();
+      for (int i = rdns.size() - 1; i >= 0; i--) {
+        final Rdn rds = rdns.get(i);
+        final Attributes attributes = rds.toAttributes();
+        final Attribute cn = attributes.get("cn");
+        if (cn != null) {
+          try {
+            final Object value = cn.get();
+            if (value != null) {
+              return value.toString();
+            }
+          } catch (final NoSuchElementException ignore) {
+          } catch (final NamingException ignore) {
+          }
+        }
+      }
+      return null;
+    } catch (final InvalidNameException e) {
+      throw new SSLException(subjectPrincipal + " is not a valid X500 distinguished name");
+    }
+  }
+
+  static List<String> extractSubjectAlts(final X509Certificate cert, final int subjectType) {
+    Collection<List<?>> c = null;
+    try {
+      c = cert.getSubjectAlternativeNames();
+    } catch(final CertificateParsingException ignore) {
+    }
+    List<String> subjectAltList = null;
+    if (c != null) {
+      for (final List<?> aC : c) {
+        final List<?> list = aC;
+        final int type = ((Integer) list.get(0)).intValue();
+        if (type == subjectType) {
+          final String s = (String) list.get(1);
+          if (subjectAltList == null) {
+            subjectAltList = new ArrayList<String>();
+          }
+          subjectAltList.add(s);
+        }
+      }
+    }
+    return subjectAltList;
+  }
+
+  /*
+   * Normalize IPv6 or DNS name.
+   */
+  static String normaliseAddress(final String hostname) {
+    if (hostname == null) {
+      return hostname;
+    }
+    try {
+      final InetAddress inetAddress = InetAddress.getByName(hostname);
+      return inetAddress.getHostAddress();
+    } catch (final UnknownHostException unexpected) { // Should not happen, because we check for IPv6 address above
+      return hostname;
+    }
+  }
+
+  public final void verify(String host, SSLSocket ssl) throws IOException {
+    if(host == null) {
+      throw new NullPointerException("host to verify is null");
+    } else {
+      SSLSession session = ssl.getSession();
+      if(session == null) {
+        InputStream certs = ssl.getInputStream();
+        certs.available();
+        session = ssl.getSession();
+        if(session == null) {
+          ssl.startHandshake();
+          session = ssl.getSession();
+        }
+      }
+
+      Certificate[] certs1 = session.getPeerCertificates();
+      X509Certificate x509 = (X509Certificate)certs1[0];
+      this.verify(host, x509);
+    }
+  }
+
+  public void verify(String var1, String[] var2, String[] var3) throws SSLException {
+    throw new UnsupportedOperationException("Not supported with this hack");
+  }
+}
\ No newline at end of file
diff --git a/jdbc/src/java/org/apache/http/conn_452/util/DomainType.java b/jdbc/src/java/org/apache/http/conn_452/util/DomainType.java
new file mode 100644
index 0000000..148de7e
--- /dev/null
+++ b/jdbc/src/java/org/apache/http/conn_452/util/DomainType.java
@@ -0,0 +1,38 @@
+/*
+ * ====================================================================
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ *
+ */
+package org.apache.http.conn_452.util;
+
+/**
+ * Domain types differentiated by Mozilla Public Suffix List.
+ *
+ * @since 4.5
+ */
+public enum DomainType {
+
+  UNKNOWN, ICANN, PRIVATE
+
+}
\ No newline at end of file
diff --git a/jdbc/src/java/org/apache/http/conn_452/util/InetAddressUtils.java b/jdbc/src/java/org/apache/http/conn_452/util/InetAddressUtils.java
new file mode 100644
index 0000000..55deeb2
--- /dev/null
+++ b/jdbc/src/java/org/apache/http/conn_452/util/InetAddressUtils.java
@@ -0,0 +1,124 @@
+/*
+ * ====================================================================
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ *
+ */
+
+package org.apache.http.conn_452.util;
+
+import java.util.regex.Pattern;
+
+import org.apache.http.annotation.Immutable;
+
+/**
+ * A collection of utilities relating to InetAddresses.
+ *
+ * @since 4.0
+ */
+@Immutable
+public class InetAddressUtils {
+
+  private InetAddressUtils() {
+  }
+
+  private static final String IPV4_BASIC_PATTERN_STRING =
+      "(([1-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){1}" + // initial first field, 1-255
+          "(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){2}" + // following 2 fields, 0-255 followed by .
+          "([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])"; // final field, 0-255
+
+  private static final Pattern IPV4_PATTERN =
+      Pattern.compile("^" + IPV4_BASIC_PATTERN_STRING + "$");
+
+  private static final Pattern IPV4_MAPPED_IPV6_PATTERN = // TODO does not allow for redundant leading zeros
+      Pattern.compile("^::[fF]{4}:" + IPV4_BASIC_PATTERN_STRING + "$");
+
+  private static final Pattern IPV6_STD_PATTERN =
+      Pattern.compile(
+          "^[0-9a-fA-F]{1,4}(:[0-9a-fA-F]{1,4}){7}$");
+
+  private static final Pattern IPV6_HEX_COMPRESSED_PATTERN =
+      Pattern.compile(
+          "^(([0-9A-Fa-f]{1,4}(:[0-9A-Fa-f]{1,4}){0,5})?)" + // 0-6 hex fields
+              "::" +
+              "(([0-9A-Fa-f]{1,4}(:[0-9A-Fa-f]{1,4}){0,5})?)$"); // 0-6 hex fields
+
+  /*
+   *  The above pattern is not totally rigorous as it allows for more than 7 hex fields in total
+   */
+  private static final char COLON_CHAR = ':';
+
+  // Must not have more than 7 colons (i.e. 8 fields)
+  private static final int MAX_COLON_COUNT = 7;
+
+  /**
+   * Checks whether the parameter is a valid IPv4 address
+   *
+   * @param input the address string to check for validity
+   * @return true if the input parameter is a valid IPv4 address
+   */
+  public static boolean isIPv4Address(final String input) {
+    return IPV4_PATTERN.matcher(input).matches();
+  }
+
+  public static boolean isIPv4MappedIPv64Address(final String input) {
+    return IPV4_MAPPED_IPV6_PATTERN.matcher(input).matches();
+  }
+
+  /**
+   * Checks whether the parameter is a valid standard (non-compressed) IPv6 address
+   *
+   * @param input the address string to check for validity
+   * @return true if the input parameter is a valid standard (non-compressed) IPv6 address
+   */
+  public static boolean isIPv6StdAddress(final String input) {
+    return IPV6_STD_PATTERN.matcher(input).matches();
+  }
+
+  /**
+   * Checks whether the parameter is a valid compressed IPv6 address
+   *
+   * @param input the address string to check for validity
+   * @return true if the input parameter is a valid compressed IPv6 address
+   */
+  public static boolean isIPv6HexCompressedAddress(final String input) {
+    int colonCount = 0;
+    for(int i = 0; i < input.length(); i++) {
+      if (input.charAt(i) == COLON_CHAR) {
+        colonCount++;
+      }
+    }
+    return  colonCount <= MAX_COLON_COUNT && IPV6_HEX_COMPRESSED_PATTERN.matcher(input).matches();
+  }
+
+  /**
+   * Checks whether the parameter is a valid IPv6 address (including compressed).
+   *
+   * @param input the address string to check for validity
+   * @return true if the input parameter is a valid standard or compressed IPv6 address
+   */
+  public static boolean isIPv6Address(final String input) {
+    return isIPv6StdAddress(input) || isIPv6HexCompressedAddress(input);
+  }
+
+}
\ No newline at end of file
diff --git a/jdbc/src/java/org/apache/http/conn_452/util/PublicSuffixList.java b/jdbc/src/java/org/apache/http/conn_452/util/PublicSuffixList.java
new file mode 100644
index 0000000..a84ce85
--- /dev/null
+++ b/jdbc/src/java/org/apache/http/conn_452/util/PublicSuffixList.java
@@ -0,0 +1,79 @@
+/*
+ * ====================================================================
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ *
+ */
+package org.apache.http.conn_452.util;
+
+import java.util.Collections;
+import java.util.List;
+
+import org.apache.http.annotation.Immutable;
+import org.apache.http.util_444.Args;
+
+/**
+ * Public suffix is a set of DNS names or wildcards concatenated with dots. It represents
+ * the part of a domain name which is not under the control of the individual registrant
+ * <p>
+ * An up-to-date list of suffixes can be obtained from
+ * <a href="http://publicsuffix.org/">publicsuffix.org</a>
+ *
+ * @since 4.4
+ */
+@Immutable
+public final class PublicSuffixList {
+
+  private final DomainType type;
+  private final List<String> rules;
+  private final List<String> exceptions;
+
+  /**
+   * @since 4.5
+   */
+  public PublicSuffixList(final DomainType type, final List<String> rules, final List<String> exceptions) {
+    this.type = Args.notNull(type, "Domain type");
+    this.rules = Collections.unmodifiableList(Args.notNull(rules, "Domain suffix rules"));
+    this.exceptions = Collections.unmodifiableList(exceptions != null ? exceptions : Collections.<String>emptyList());
+  }
+
+  public PublicSuffixList(final List<String> rules, final List<String> exceptions) {
+    this(DomainType.UNKNOWN, rules, exceptions);
+  }
+
+  /**
+   * @since 4.5
+   */
+  public DomainType getType() {
+    return type;
+  }
+
+  public List<String> getRules() {
+    return rules;
+  }
+
+  public List<String> getExceptions() {
+    return exceptions;
+  }
+
+}
\ No newline at end of file
diff --git a/jdbc/src/java/org/apache/http/conn_452/util/PublicSuffixMatcher.java b/jdbc/src/java/org/apache/http/conn_452/util/PublicSuffixMatcher.java
new file mode 100644
index 0000000..f9fad18
--- /dev/null
+++ b/jdbc/src/java/org/apache/http/conn_452/util/PublicSuffixMatcher.java
@@ -0,0 +1,202 @@
+/*
+ * ====================================================================
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ *
+ */
+package org.apache.http.conn_452.util;
+
+import java.net.IDN;
+import java.util.Collection;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+import org.apache.http.annotation.ThreadSafe;
+import org.apache.http.util_444.Args;
+
+/**
+ * Utility class that can test if DNS names match the content of the Public Suffix List.
+ * <p>
+ * An up-to-date list of suffixes can be obtained from
+ * <a href="http://publicsuffix.org/">publicsuffix.org</a>
+ *
+ * @see org.apache.http.conn.util.PublicSuffixList
+ *
+ * @since 4.4
+ */
+@ThreadSafe
+public final class PublicSuffixMatcher {
+
+  private final Map<String, DomainType> rules;
+  private final Map<String, DomainType> exceptions;
+
+  public PublicSuffixMatcher(final Collection<String> rules, final Collection<String> exceptions) {
+    this(DomainType.UNKNOWN, rules, exceptions);
+  }
+
+  /**
+   * @since 4.5
+   */
+  public PublicSuffixMatcher(
+                                final DomainType domainType, final Collection<String> rules, final Collection<String> exceptions) {
+    Args.notNull(domainType,  "Domain type");
+    Args.notNull(rules,  "Domain suffix rules");
+    this.rules = new ConcurrentHashMap<String, DomainType>(rules.size());
+    for (final String rule: rules) {
+      this.rules.put(rule, domainType);
+    }
+    this.exceptions = new ConcurrentHashMap<String, DomainType>();
+    if (exceptions != null) {
+      for (final String exception: exceptions) {
+        this.exceptions.put(exception, domainType);
+      }
+    }
+  }
+
+  /**
+   * @since 4.5
+   */
+  public PublicSuffixMatcher(final Collection<PublicSuffixList> lists) {
+    Args.notNull(lists,  "Domain suffix lists");
+    this.rules = new ConcurrentHashMap<String, DomainType>();
+    this.exceptions = new ConcurrentHashMap<String, DomainType>();
+    for (final PublicSuffixList list: lists) {
+      final DomainType domainType = list.getType();
+      final List<String> rules = list.getRules();
+      for (final String rule: rules) {
+        this.rules.put(rule, domainType);
+      }
+      final List<String> exceptions = list.getExceptions();
+      if (exceptions != null) {
+        for (final String exception: exceptions) {
+          this.exceptions.put(exception, domainType);
+        }
+      }
+    }
+  }
+
+  private static boolean hasEntry(final Map<String, DomainType> map, final String rule, final DomainType expectedType) {
+    if (map == null) {
+      return false;
+    }
+    final DomainType domainType = map.get(rule);
+    if (domainType == null) {
+      return false;
+    } else {
+      return expectedType == null || domainType.equals(expectedType);
+    }
+  }
+
+  private boolean hasRule(final String rule, final DomainType expectedType) {
+    return hasEntry(this.rules, rule, expectedType);
+  }
+
+  private boolean hasException(final String exception, final DomainType expectedType) {
+    return hasEntry(this.exceptions, exception, expectedType);
+  }
+
+  /**
+   * Returns registrable part of the domain for the given domain name or {@code null}
+   * if given domain represents a public suffix.
+   *
+   * @param domain
+   * @return domain root
+   */
+  public String getDomainRoot(final String domain) {
+    return getDomainRoot(domain, null);
+  }
+
+  /**
+   * Returns registrable part of the domain for the given domain name or {@code null}
+   * if given domain represents a public suffix.
+   *
+   * @param domain
+   * @param expectedType expected domain type or {@code null} if any.
+   * @return domain root
+   *
+   * @since 4.5
+   */
+  public String getDomainRoot(final String domain, final DomainType expectedType) {
+    if (domain == null) {
+      return null;
+    }
+    if (domain.startsWith(".")) {
+      return null;
+    }
+    String domainName = null;
+    String segment = domain.toLowerCase(Locale.ROOT);
+    while (segment != null) {
+
+      // An exception rule takes priority over any other matching rule.
+      if (hasException(IDN.toUnicode(segment), expectedType)) {
+        return segment;
+      }
+
+      if (hasRule(IDN.toUnicode(segment), expectedType)) {
+        break;
+      }
+
+      final int nextdot = segment.indexOf('.');
+      final String nextSegment = nextdot != -1 ? segment.substring(nextdot + 1) : null;
+
+      if (nextSegment != null) {
+        if (hasRule("*." + IDN.toUnicode(nextSegment), expectedType)) {
+          break;
+        }
+      }
+      if (nextdot != -1) {
+        domainName = segment;
+      }
+      segment = nextSegment;
+    }
+    return domainName;
+  }
+
+  /**
+   * Tests whether the given domain matches any of entry from the public suffix list.
+   */
+  public boolean matches(final String domain) {
+    return matches(domain, null);
+  }
+
+  /**
+   * Tests whether the given domain matches any of entry from the public suffix list.
+   *
+   * @param domain
+   * @param expectedType expected domain type or {@code null} if any.
+   * @return {@code true} if the given domain matches any of the public suffixes.
+   *
+   * @since 4.5
+   */
+  public boolean matches(final String domain, final DomainType expectedType) {
+    if (domain == null) {
+      return false;
+    }
+    final String domainRoot = getDomainRoot(
+        domain.startsWith(".") ? domain.substring(1) : domain, expectedType);
+    return domainRoot == null;
+  }
+
+}
\ No newline at end of file
diff --git a/jdbc/src/java/org/apache/http/util_444/Args.java b/jdbc/src/java/org/apache/http/util_444/Args.java
new file mode 100644
index 0000000..55bb712
--- /dev/null
+++ b/jdbc/src/java/org/apache/http/util_444/Args.java
@@ -0,0 +1,127 @@
+/*
+ * ====================================================================
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ *
+ */
+
+package org.apache.http.util_444;
+
+import java.util.Collection;
+
+public class Args {
+
+  public static void check(final boolean expression, final String message) {
+    if (!expression) {
+      throw new IllegalArgumentException(message);
+    }
+  }
+
+  public static void check(final boolean expression, final String message, final Object... args) {
+    if (!expression) {
+      throw new IllegalArgumentException(String.format(message, args));
+    }
+  }
+
+  public static void check(final boolean expression, final String message, final Object arg) {
+    if (!expression) {
+      throw new IllegalArgumentException(String.format(message, arg));
+    }
+  }
+
+  public static <T> T notNull(final T argument, final String name) {
+    if (argument == null) {
+      throw new IllegalArgumentException(name + " may not be null");
+    }
+    return argument;
+  }
+
+  public static <T extends CharSequence> T notEmpty(final T argument, final String name) {
+    if (argument == null) {
+      throw new IllegalArgumentException(name + " may not be null");
+    }
+    if (TextUtils.isEmpty(argument)) {
+      throw new IllegalArgumentException(name + " may not be empty");
+    }
+    return argument;
+  }
+
+  public static <T extends CharSequence> T notBlank(final T argument, final String name) {
+    if (argument == null) {
+      throw new IllegalArgumentException(name + " may not be null");
+    }
+    if (TextUtils.isBlank(argument)) {
+      throw new IllegalArgumentException(name + " may not be blank");
+    }
+    return argument;
+  }
+
+  public static <T extends CharSequence> T containsNoBlanks(final T argument, final String name) {
+    if (argument == null) {
+      throw new IllegalArgumentException(name + " may not be null");
+    }
+    if (TextUtils.containsBlanks(argument)) {
+      throw new IllegalArgumentException(name + " may not contain blanks");
+    }
+    return argument;
+  }
+
+  public static <E, T extends Collection<E>> T notEmpty(final T argument, final String name) {
+    if (argument == null) {
+      throw new IllegalArgumentException(name + " may not be null");
+    }
+    if (argument.isEmpty()) {
+      throw new IllegalArgumentException(name + " may not be empty");
+    }
+    return argument;
+  }
+
+  public static int positive(final int n, final String name) {
+    if (n <= 0) {
+      throw new IllegalArgumentException(name + " may not be negative or zero");
+    }
+    return n;
+  }
+
+  public static long positive(final long n, final String name) {
+    if (n <= 0) {
+      throw new IllegalArgumentException(name + " may not be negative or zero");
+    }
+    return n;
+  }
+
+  public static int notNegative(final int n, final String name) {
+    if (n < 0) {
+      throw new IllegalArgumentException(name + " may not be negative");
+    }
+    return n;
+  }
+
+  public static long notNegative(final long n, final String name) {
+    if (n < 0) {
+      throw new IllegalArgumentException(name + " may not be negative");
+    }
+    return n;
+  }
+
+}
\ No newline at end of file
diff --git a/jdbc/src/java/org/apache/http/util_444/TextUtils.java b/jdbc/src/java/org/apache/http/util_444/TextUtils.java
new file mode 100644
index 0000000..f4122dc
--- /dev/null
+++ b/jdbc/src/java/org/apache/http/util_444/TextUtils.java
@@ -0,0 +1,75 @@
+/*
+ * ====================================================================
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ *
+ */
+
+package org.apache.http.util_444;
+
+/**
+ * @since 4.3
+ */
+public final class TextUtils {
+
+  /**
+   * Returns true if the parameter is null or of zero length
+   */
+  public static boolean isEmpty(final CharSequence s) {
+    if (s == null) {
+      return true;
+    }
+    return s.length() == 0;
+  }
+
+  /**
+   * Returns true if the parameter is null or contains only whitespace
+   */
+  public static boolean isBlank(final CharSequence s) {
+    if (s == null) {
+      return true;
+    }
+    for (int i = 0; i < s.length(); i++) {
+      if (!Character.isWhitespace(s.charAt(i))) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  /**
+   * @since 4.4
+   */
+  public static boolean containsBlanks(final CharSequence s) {
+    if (s == null) {
+      return false;
+    }
+    for (int i = 0; i < s.length(); i++) {
+      if (Character.isWhitespace(s.charAt(i))) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+}
\ No newline at end of file
-- 
1.7.9.5

