From 490352dc7f241b33deb2f9bf02adebe3997296ed Mon Sep 17 00:00:00 2001
From: Vaibhav Gumashta <vgumashta@apache.org>
Date: Thu, 9 Jul 2015 22:53:21 +0530
Subject: [PATCH 0190/1164] HIVE-10895: ObjectStore does not close Query
 objects in some calls, causing a potential leak
 in some metastore db resources (Aihua Xu reviewed
 by Chaoyu Tang, Sergey Shelukhin, Vaibhav
 Gumashta)

Conflicts:
	metastore/src/java/org/apache/hadoop/hive/metastore/ObjectStore.java
---
 .../hadoop/hive/metastore/MetaStoreDirectSql.java  |   56 +-
 .../apache/hadoop/hive/metastore/ObjectStore.java  | 1836 +++++++++++---------
 .../hadoop/hive/metastore/tools/HiveMetaTool.java  |   23 +-
 .../hadoop/hive/metastore/TestObjectStore.java     |  228 +++
 4 files changed, 1327 insertions(+), 816 deletions(-)
 create mode 100644 metastore/src/test/org/apache/hadoop/hive/metastore/TestObjectStore.java

diff --git a/metastore/src/java/org/apache/hadoop/hive/metastore/MetaStoreDirectSql.java b/metastore/src/java/org/apache/hadoop/hive/metastore/MetaStoreDirectSql.java
index 574141c..28252f1 100644
--- a/metastore/src/java/org/apache/hadoop/hive/metastore/MetaStoreDirectSql.java
+++ b/metastore/src/java/org/apache/hadoop/hive/metastore/MetaStoreDirectSql.java
@@ -165,25 +165,44 @@ private String getProductName() {
 
   private boolean ensureDbInit() {
     Transaction tx = pm.currentTransaction();
+    Query dbQuery = null, tblColumnQuery = null, partColumnQuery = null;
     try {
       // Force the underlying db to initialize.
-      pm.newQuery(MDatabase.class, "name == ''").execute();
-      pm.newQuery(MTableColumnStatistics.class, "dbName == ''").execute();
-      pm.newQuery(MPartitionColumnStatistics.class, "dbName == ''").execute();
+      dbQuery = pm.newQuery(MDatabase.class, "name == ''");
+      dbQuery.execute();
+
+      tblColumnQuery = pm.newQuery(MTableColumnStatistics.class, "dbName == ''");
+      tblColumnQuery.execute();
+
+      partColumnQuery = pm.newQuery(MPartitionColumnStatistics.class, "dbName == ''");
+      partColumnQuery.execute();
+
       return true;
     } catch (Exception ex) {
       LOG.warn("Database initialization failed; direct SQL is disabled", ex);
       tx.rollback();
       return false;
+    } finally {
+      if (dbQuery != null) {
+        dbQuery.closeAll();
+      }
+      if (tblColumnQuery != null) {
+        tblColumnQuery.closeAll();
+      }
+      if (partColumnQuery != null) {
+        partColumnQuery.closeAll();
+      }
     }
   }
 
   private boolean runTestQuery() {
     Transaction tx = pm.currentTransaction();
+    Query query = null;
     // Run a self-test query. If it doesn't work, we will self-disable. What a PITA...
     String selfTestQuery = "select \"DB_ID\" from \"DBS\"";
     try {
-      pm.newQuery("javax.jdo.query.SQL", selfTestQuery).execute();
+      query = pm.newQuery("javax.jdo.query.SQL", selfTestQuery);
+      query.execute();
       tx.commit();
       return true;
     } catch (Exception ex) {
@@ -191,6 +210,11 @@ private boolean runTestQuery() {
       tx.rollback();
       return false;
     }
+    finally {
+      if (query != null) {
+        query.closeAll();
+      }
+    }
   }
 
   public boolean isCompatibleDatastore() {
@@ -380,14 +404,21 @@ private static Boolean isViewTable(Table t) {
   }
 
   private boolean isViewTable(String dbName, String tblName) throws MetaException {
-    String queryText = "select \"TBL_TYPE\" from \"TBLS\"" +
-        " inner join \"DBS\" on \"TBLS\".\"DB_ID\" = \"DBS\".\"DB_ID\" " +
-        " where \"TBLS\".\"TBL_NAME\" = ? and \"DBS\".\"NAME\" = ?";
-    Object[] params = new Object[] { tblName, dbName };
-    Query query = pm.newQuery("javax.jdo.query.SQL", queryText);
-    query.setUnique(true);
-    Object result = executeWithArray(query, params, queryText);
-    return (result != null) && result.toString().equals(TableType.VIRTUAL_VIEW.toString());
+    Query query = null;
+    try {
+      String queryText = "select \"TBL_TYPE\" from \"TBLS\"" +
+          " inner join \"DBS\" on \"TBLS\".\"DB_ID\" = \"DBS\".\"DB_ID\" " +
+          " where \"TBLS\".\"TBL_NAME\" = ? and \"DBS\".\"NAME\" = ?";
+      Object[] params = new Object[] { tblName, dbName };
+      query = pm.newQuery("javax.jdo.query.SQL", queryText);
+      query.setUnique(true);
+      Object result = executeWithArray(query, params, queryText);
+      return (result != null) && result.toString().equals(TableType.VIRTUAL_VIEW.toString());
+    } finally {
+      if (query != null) {
+        query.closeAll();
+      }
+    }
   }
 
   /**
@@ -1110,6 +1141,7 @@ private long partsFoundForPartitions(String dbName, String tableName,
         partsFound++;
       }
     }
+    query.closeAll();
     return partsFound;
   }
 
diff --git a/metastore/src/java/org/apache/hadoop/hive/metastore/ObjectStore.java b/metastore/src/java/org/apache/hadoop/hive/metastore/ObjectStore.java
index fcba1c6..7f2bef6 100644
--- a/metastore/src/java/org/apache/hadoop/hive/metastore/ObjectStore.java
+++ b/metastore/src/java/org/apache/hadoop/hive/metastore/ObjectStore.java
@@ -217,6 +217,29 @@
 
   private Pattern partitionValidationPattern;
 
+  /**
+   * A class to pass the Query object to the caller to let the caller release
+   * resources by calling QueryWrapper.query.closeAll() after consuming all the query results.
+   */
+  public static class QueryWrapper {
+    public Query query;
+
+    /**
+     * Explicitly closes the query object to release the resources
+     */
+    public void close() {
+      if (query != null) {
+        query.closeAll();
+        query = null;
+      }
+    }
+
+    @Override
+    protected void finalize() {
+      this.close();
+    }
+  }
+
   public ObjectStore() {
   }
 
@@ -551,10 +574,11 @@ public void createDatabase(Database db) throws InvalidObjectException, MetaExcep
   private MDatabase getMDatabase(String name) throws NoSuchObjectException {
     MDatabase mdb = null;
     boolean commited = false;
+    Query query = null;
     try {
       openTransaction();
       name = HiveStringUtils.normalizeIdentifier(name);
-      Query query = pm.newQuery(MDatabase.class, "name == dbname");
+      query = pm.newQuery(MDatabase.class, "name == dbname");
       query.declareParameters("java.lang.String dbname");
       query.setUnique(true);
       mdb = (MDatabase) query.execute(name);
@@ -564,6 +588,9 @@ private MDatabase getMDatabase(String name) throws NoSuchObjectException {
       if (!commited) {
         rollbackTransaction();
       }
+      if (query != null) {
+        query.closeAll();
+      }
     }
     if (mdb == null) {
       throw new NoSuchObjectException("There is no database named " + name);
@@ -666,6 +693,7 @@ public boolean dropDatabase(String dbname) throws NoSuchObjectException, MetaExc
     boolean success = false;
     LOG.info("Dropping database " + dbname + " along with all tables");
     dbname = HiveStringUtils.normalizeIdentifier(dbname);
+    QueryWrapper queryWrapper = new QueryWrapper();
     try {
       openTransaction();
 
@@ -673,7 +701,7 @@ public boolean dropDatabase(String dbname) throws NoSuchObjectException, MetaExc
       MDatabase db = getMDatabase(dbname);
       pm.retrieve(db);
       if (db != null) {
-        List<MDBPrivilege> dbGrants = this.listDatabaseGrants(dbname);
+        List<MDBPrivilege> dbGrants = this.listDatabaseGrants(dbname, queryWrapper);
         if (dbGrants != null && dbGrants.size() > 0) {
           pm.deletePersistentAll(dbGrants);
         }
@@ -684,36 +712,36 @@ public boolean dropDatabase(String dbname) throws NoSuchObjectException, MetaExc
       if (!success) {
         rollbackTransaction();
       }
+      queryWrapper.close();
     }
     return success;
   }
 
-
   @Override
   public List<String> getDatabases(String pattern) throws MetaException {
     boolean commited = false;
     List<String> databases = null;
+    Query query = null;
     try {
       openTransaction();
       // Take the pattern and split it on the | to get all the composing
       // patterns
       String[] subpatterns = pattern.trim().split("\\|");
-      String query = "select name from org.apache.hadoop.hive.metastore.model.MDatabase where (";
+      String queryStr = "select name from org.apache.hadoop.hive.metastore.model.MDatabase where (";
       boolean first = true;
       for (String subpattern : subpatterns) {
         subpattern = "(?i)" + subpattern.replaceAll("\\*", ".*");
         if (!first) {
-          query = query + " || ";
+          queryStr = queryStr + " || ";
         }
-        query = query + " name.matches(\"" + subpattern + "\")";
+        queryStr = queryStr + " name.matches(\"" + subpattern + "\")";
         first = false;
       }
-      query = query + ")";
-
-      Query q = pm.newQuery(query);
-      q.setResult("name");
-      q.setOrdering("name ascending");
-      Collection names = (Collection) q.execute();
+      queryStr = queryStr + ")";
+      query = pm.newQuery(queryStr);
+      query.setResult("name");
+      query.setOrdering("name ascending");
+      Collection names = (Collection) query.execute();
       databases = new ArrayList<String>();
       for (Iterator i = names.iterator(); i.hasNext();) {
         databases.add((String) i.next());
@@ -723,6 +751,9 @@ public boolean dropDatabase(String dbname) throws NoSuchObjectException, MetaExc
       if (!commited) {
         rollbackTransaction();
       }
+      if (query != null) {
+        query.closeAll();
+      }
     }
     return databases;
   }
@@ -781,9 +812,10 @@ public boolean createType(Type type) {
   public Type getType(String typeName) {
     Type type = null;
     boolean commited = false;
+    Query query = null;
     try {
       openTransaction();
-      Query query = pm.newQuery(MType.class, "name == typeName");
+      query = pm.newQuery(MType.class, "name == typeName");
       query.declareParameters("java.lang.String typeName");
       query.setUnique(true);
       MType mtype = (MType) query.execute(typeName.trim());
@@ -796,6 +828,9 @@ public Type getType(String typeName) {
       if (!commited) {
         rollbackTransaction();
       }
+      if (query != null) {
+        query.closeAll();
+      }
     }
     return type;
   }
@@ -803,9 +838,10 @@ public Type getType(String typeName) {
   @Override
   public boolean dropType(String typeName) {
     boolean success = false;
+    Query query = null;
     try {
       openTransaction();
-      Query query = pm.newQuery(MType.class, "name == typeName");
+      query = pm.newQuery(MType.class, "name == typeName");
       query.declareParameters("java.lang.String typeName");
       query.setUnique(true);
       MType type = (MType) query.execute(typeName.trim());
@@ -821,6 +857,9 @@ public boolean dropType(String typeName) {
       if (!success) {
         rollbackTransaction();
       }
+      if (query != null) {
+        query.closeAll();
+      }
     }
     return success;
   }
@@ -956,9 +995,9 @@ public Table getTable(String dbName, String tableName) throws MetaException {
   }
 
   @Override
-  public List<String> getTables(String dbName, String pattern)
-      throws MetaException {
+  public List<String> getTables(String dbName, String pattern) throws MetaException {
     boolean commited = false;
+    Query query = null;
     List<String> tbls = null;
     try {
       openTransaction();
@@ -966,25 +1005,24 @@ public Table getTable(String dbName, String tableName) throws MetaException {
       // Take the pattern and split it on the | to get all the composing
       // patterns
       String[] subpatterns = pattern.trim().split("\\|");
-      String query =
-        "select tableName from org.apache.hadoop.hive.metastore.model.MTable "
-        + "where database.name == dbName && (";
+      String queryStr =
+          "select tableName from org.apache.hadoop.hive.metastore.model.MTable "
+              + "where database.name == dbName && (";
       boolean first = true;
       for (String subpattern : subpatterns) {
         subpattern = "(?i)" + subpattern.replaceAll("\\*", ".*");
         if (!first) {
-          query = query + " || ";
+          queryStr = queryStr + " || ";
         }
-        query = query + " tableName.matches(\"" + subpattern + "\")";
+        queryStr = queryStr + " tableName.matches(\"" + subpattern + "\")";
         first = false;
       }
-      query = query + ")";
-
-      Query q = pm.newQuery(query);
-      q.declareParameters("java.lang.String dbName");
-      q.setResult("tableName");
-      q.setOrdering("tableName ascending");
-      Collection names = (Collection) q.execute(dbName);
+      queryStr = queryStr + ")";
+      query = pm.newQuery(queryStr);
+      query.declareParameters("java.lang.String dbName");
+      query.setResult("tableName");
+      query.setOrdering("tableName ascending");
+      Collection names = (Collection) query.execute(dbName);
       tbls = new ArrayList<String>();
       for (Iterator i = names.iterator(); i.hasNext();) {
         tbls.add((String) i.next());
@@ -994,6 +1032,9 @@ public Table getTable(String dbName, String tableName) throws MetaException {
       if (!commited) {
         rollbackTransaction();
       }
+      if (query != null) {
+        query.closeAll();
+      }
     }
     return tbls;
   }
@@ -1006,11 +1047,12 @@ public Table getTable(String dbName, String tableName) throws MetaException {
   private MTable getMTable(String db, String table) {
     MTable mtbl = null;
     boolean commited = false;
+    Query query = null;
     try {
       openTransaction();
       db = HiveStringUtils.normalizeIdentifier(db);
       table = HiveStringUtils.normalizeIdentifier(table);
-      Query query = pm.newQuery(MTable.class, "tableName == table && database.name == db");
+      query = pm.newQuery(MTable.class, "tableName == table && database.name == db");
       query.declareParameters("java.lang.String table, java.lang.String db");
       query.setUnique(true);
       mtbl = (MTable) query.execute(table, db);
@@ -1020,20 +1062,24 @@ private MTable getMTable(String db, String table) {
       if (!commited) {
         rollbackTransaction();
       }
+      if (query != null) {
+        query.closeAll();
+      }
     }
     return mtbl;
   }
 
   @Override
-  public List<Table> getTableObjectsByName(String db, List<String> tbl_names)
-      throws MetaException, UnknownDBException {
+  public List<Table> getTableObjectsByName(String db, List<String> tbl_names) throws MetaException,
+      UnknownDBException {
     List<Table> tables = new ArrayList<Table>();
     boolean committed = false;
+    Query dbExistsQuery = null;
+    Query query = null;
     try {
       openTransaction();
-
       db = HiveStringUtils.normalizeIdentifier(db);
-      Query dbExistsQuery = pm.newQuery(MDatabase.class, "name == db");
+      dbExistsQuery = pm.newQuery(MDatabase.class, "name == db");
       dbExistsQuery.declareParameters("java.lang.String db");
       dbExistsQuery.setUnique(true);
       dbExistsQuery.setResult("name");
@@ -1046,7 +1092,7 @@ private MTable getMTable(String db, String table) {
       for (String t : tbl_names) {
         lowered_tbl_names.add(HiveStringUtils.normalizeIdentifier(t));
       }
-      Query query = pm.newQuery(MTable.class);
+      query = pm.newQuery(MTable.class);
       query.setFilter("database.name == db && tbl_names.contains(tableName)");
       query.declareParameters("java.lang.String db, java.util.Collection tbl_names");
       Collection mtables = (Collection) query.execute(db, lowered_tbl_names);
@@ -1058,6 +1104,12 @@ private MTable getMTable(String db, String table) {
       if (!committed) {
         rollbackTransaction();
       }
+      if (dbExistsQuery != null) {
+        dbExistsQuery.closeAll();
+      }
+      if (query != null) {
+        query.closeAll();
+      }
     }
     return tables;
   }
@@ -1208,9 +1260,9 @@ private MColumnDescriptor createNewMColumnDescriptor(List<MFieldSchema> cols) {
 
   // MSD and SD should be same objects. Not sure how to make then same right now
   // MSerdeInfo *& SerdeInfo should be same as well
-  private StorageDescriptor convertToStorageDescriptor(MStorageDescriptor msd,
-      boolean noFS)
-      throws MetaException {
+  private StorageDescriptor convertToStorageDescriptor(
+      MStorageDescriptor msd,
+      boolean noFS) throws MetaException {
     if (msd == null) {
       return null;
     }
@@ -1296,8 +1348,6 @@ private StorageDescriptor convertToStorageDescriptor(MStorageDescriptor msd)
     return map;
   }
 
-
-
   /**
    * Converts a storage descriptor to a db-backed storage descriptor.  Creates a
    *   new db-backed column descriptor object for this SD.
@@ -1404,7 +1454,6 @@ private boolean isValidPartition(
     return !doesExist;
   }
 
-
   @Override
   public boolean addPartitions(String dbName, String tblName,
                                PartitionSpecProxy partitionSpec, boolean ifNotExists)
@@ -1531,10 +1580,11 @@ public Partition getPartition(String dbName, String tableName,
     return part;
   }
 
-  private MPartition getMPartition(String dbName, String tableName,
-      List<String> part_vals) throws MetaException {
+  private MPartition getMPartition(String dbName, String tableName, List<String> part_vals)
+      throws MetaException {
     MPartition mpart = null;
     boolean commited = false;
+    Query query = null;
     try {
       openTransaction();
       dbName = HiveStringUtils.normalizeIdentifier(dbName);
@@ -1546,10 +1596,11 @@ private MPartition getMPartition(String dbName, String tableName,
       }
       // Change the query to use part_vals instead of the name which is
       // redundant TODO: callers of this often get part_vals out of name for no reason...
-      String name = Warehouse.makePartName(convertToFieldSchemas(mtbl
-          .getPartitionKeys()), part_vals);
-      Query query = pm.newQuery(MPartition.class,
-          "table.tableName == t1 && table.database.name == t2 && partitionName == t3");
+      String name =
+          Warehouse.makePartName(convertToFieldSchemas(mtbl.getPartitionKeys()), part_vals);
+      query =
+          pm.newQuery(MPartition.class,
+              "table.tableName == t1 && table.database.name == t2 && partitionName == t3");
       query.declareParameters("java.lang.String t1, java.lang.String t2, java.lang.String t3");
       query.setUnique(true);
       mpart = (MPartition) query.execute(tableName, dbName, name);
@@ -1559,6 +1610,9 @@ private MPartition getMPartition(String dbName, String tableName,
       if (!commited) {
         rollbackTransaction();
       }
+      if (query != null) {
+        query.closeAll();
+      }
     }
     return mpart;
   }
@@ -1750,8 +1804,13 @@ private boolean dropPartitionCommon(MPartition part) throws NoSuchObjectExceptio
       }
       @Override
       protected List<Partition> getJdoResult(
-          GetHelper<List<Partition>> ctx) throws MetaException, NoSuchObjectException {
-        return convertToParts(listMPartitions(dbName, tblName, maxParts));
+          GetHelper<List<Partition>> ctx) throws MetaException {
+        QueryWrapper queryWrapper = new QueryWrapper();
+        try {
+          return convertToParts(listMPartitions(dbName, tblName, maxParts, queryWrapper));
+        } finally {
+          queryWrapper.close();
+        }
       }
     }.run(false);
   }
@@ -1759,11 +1818,13 @@ private boolean dropPartitionCommon(MPartition part) throws NoSuchObjectExceptio
   @Override
   public List<Partition> getPartitionsWithAuth(String dbName, String tblName,
       short max, String userName, List<String> groupNames)
-      throws MetaException, NoSuchObjectException, InvalidObjectException {
+          throws MetaException, InvalidObjectException {
     boolean success = false;
+    QueryWrapper queryWrapper = new QueryWrapper();
+
     try {
       openTransaction();
-      List<MPartition> mparts = listMPartitions(dbName, tblName, max);
+      List<MPartition> mparts = listMPartitions(dbName, tblName, max, queryWrapper);
       List<Partition> parts = new ArrayList<Partition>(mparts.size());
       if (mparts != null && mparts.size()>0) {
         for (MPartition mpart : mparts) {
@@ -1786,6 +1847,7 @@ private boolean dropPartitionCommon(MPartition part) throws NoSuchObjectExceptio
       if (!success) {
         rollbackTransaction();
       }
+      queryWrapper.close();
     }
   }
 
@@ -1822,7 +1884,6 @@ public Partition getPartitionWithAuth(String dbName, String tblName,
     }
   }
 
-
   private List<Partition> convertToParts(List<MPartition> mparts) throws MetaException {
     return convertToParts(mparts, null);
   }
@@ -1873,20 +1934,22 @@ public Partition getPartitionWithAuth(String dbName, String tblName,
     List<String> pns = new ArrayList<String>();
     dbName = HiveStringUtils.normalizeIdentifier(dbName);
     tableName = HiveStringUtils.normalizeIdentifier(tableName);
-    Query q = pm.newQuery(
-        "select partitionName from org.apache.hadoop.hive.metastore.model.MPartition "
-        + "where table.database.name == t1 && table.tableName == t2 "
-        + "order by partitionName asc");
-    q.declareParameters("java.lang.String t1, java.lang.String t2");
-    q.setResult("partitionName");
-
-    if(max > 0) {
-      q.setRange(0, max);
-    }
-    Collection names = (Collection) q.execute(dbName, tableName);
+    Query query =
+        pm.newQuery("select partitionName from org.apache.hadoop.hive.metastore.model.MPartition "
+            + "where table.database.name == t1 && table.tableName == t2 "
+            + "order by partitionName asc");
+    query.declareParameters("java.lang.String t1, java.lang.String t2");
+    query.setResult("partitionName");
+    if (max > 0) {
+      query.setRange(0, max);
+    }
+    Collection names = (Collection) query.execute(dbName, tableName);
     for (Iterator i = names.iterator(); i.hasNext();) {
       pns.add((String) i.next());
     }
+    if (query != null) {
+      query.closeAll();
+    }
     return pns;
   }
 
@@ -1906,51 +1969,46 @@ public Partition getPartitionWithAuth(String dbName, String tblName,
    *          has types of String, and if resultsCol is null, the types are MPartition.
    */
   private Collection getPartitionPsQueryResults(String dbName, String tableName,
-      List<String> part_vals, short max_parts, String resultsCol)
+      List<String> part_vals, short max_parts, String resultsCol, QueryWrapper queryWrapper)
       throws MetaException, NoSuchObjectException {
     dbName = HiveStringUtils.normalizeIdentifier(dbName);
     tableName = HiveStringUtils.normalizeIdentifier(tableName);
     Table table = getTable(dbName, tableName);
-
     if (table == null) {
       throw new NoSuchObjectException(dbName + "." + tableName + " table not found");
     }
-
     List<FieldSchema> partCols = table.getPartitionKeys();
     int numPartKeys = partCols.size();
     if (part_vals.size() > numPartKeys) {
       throw new MetaException("Incorrect number of partition values");
     }
-
     partCols = partCols.subList(0, part_vals.size());
-    //Construct a pattern of the form: partKey=partVal/partKey2=partVal2/...
+    // Construct a pattern of the form: partKey=partVal/partKey2=partVal2/...
     // where partVal is either the escaped partition value given as input,
     // or a regex of the form ".*"
-    //This works because the "=" and "/" separating key names and partition key/values
+    // This works because the "=" and "/" separating key names and partition key/values
     // are not escaped.
     String partNameMatcher = Warehouse.makePartName(partCols, part_vals, ".*");
-    //add ".*" to the regex to match anything else afterwards the partial spec.
+    // add ".*" to the regex to match anything else afterwards the partial spec.
     if (part_vals.size() < numPartKeys) {
       partNameMatcher += ".*";
     }
-
-    Query q = pm.newQuery(MPartition.class);
+    Query query = queryWrapper.query = pm.newQuery(MPartition.class);
     StringBuilder queryFilter = new StringBuilder("table.database.name == dbName");
     queryFilter.append(" && table.tableName == tableName");
     queryFilter.append(" && partitionName.matches(partialRegex)");
-    q.setFilter(queryFilter.toString());
-    q.declareParameters("java.lang.String dbName, " +
-        "java.lang.String tableName, java.lang.String partialRegex");
-
-    if( max_parts >= 0 ) {
-      //User specified a row limit, set it on the Query
-      q.setRange(0, max_parts);
+    query.setFilter(queryFilter.toString());
+    query.declareParameters("java.lang.String dbName, "
+        + "java.lang.String tableName, java.lang.String partialRegex");
+    if (max_parts >= 0) {
+      // User specified a row limit, set it on the Query
+      query.setRange(0, max_parts);
     }
     if (resultsCol != null && !resultsCol.isEmpty()) {
-      q.setResult(resultsCol);
+      query.setResult(resultsCol);
     }
 
-    return (Collection) q.execute(dbName, tableName, partNameMatcher);
+    return (Collection) query.execute(dbName, tableName, partNameMatcher);
   }
 
   @Override
@@ -1959,11 +2017,13 @@ private Collection getPartitionPsQueryResults(String dbName, String tableName,
       throws MetaException, InvalidObjectException, NoSuchObjectException {
     List<Partition> partitions = new ArrayList<Partition>();
     boolean success = false;
+    QueryWrapper queryWrapper = new QueryWrapper();
+
     try {
       openTransaction();
       LOG.debug("executing listPartitionNamesPsWithAuth");
       Collection parts = getPartitionPsQueryResults(db_name, tbl_name,
-          part_vals, max_parts, null);
+          part_vals, max_parts, null, queryWrapper);
       MTable mtbl = getMTable(db_name, tbl_name);
       for (Object o : parts) {
         Partition part = convertToPart((MPartition) o);
@@ -1983,6 +2043,7 @@ private Collection getPartitionPsQueryResults(String dbName, String tableName,
       if (!success) {
         rollbackTransaction();
       }
+      queryWrapper.close();
     }
     return partitions;
   }
@@ -1992,11 +2053,13 @@ private Collection getPartitionPsQueryResults(String dbName, String tableName,
       List<String> part_vals, short max_parts) throws MetaException, NoSuchObjectException {
     List<String> partitionNames = new ArrayList<String>();
     boolean success = false;
+    QueryWrapper queryWrapper = new QueryWrapper();
+
     try {
       openTransaction();
       LOG.debug("Executing listPartitionNamesPs");
       Collection names = getPartitionPsQueryResults(dbName, tableName,
-          part_vals, max_parts, "partitionName");
+          part_vals, max_parts, "partitionName", queryWrapper);
       for (Object o : names) {
         partitionNames.add((String) o);
       }
@@ -2005,14 +2068,13 @@ private Collection getPartitionPsQueryResults(String dbName, String tableName,
       if (!success) {
         rollbackTransaction();
       }
+      queryWrapper.close();
     }
     return partitionNames;
   }
 
   // TODO:pc implement max
-  private List<MPartition> listMPartitions(String dbName, String tableName,
-      int max) {
-
+  private List<MPartition> listMPartitions(String dbName, String tableName, int max, QueryWrapper queryWrapper) {
     boolean success = false;
     List<MPartition> mparts = null;
     try {
@@ -2020,11 +2082,10 @@ private Collection getPartitionPsQueryResults(String dbName, String tableName,
       LOG.debug("Executing listMPartitions");
       dbName = HiveStringUtils.normalizeIdentifier(dbName);
       tableName = HiveStringUtils.normalizeIdentifier(tableName);
-      Query query = pm.newQuery(MPartition.class,
-          "table.tableName == t1 && table.database.name == t2");
+      Query query = queryWrapper.query = pm.newQuery(MPartition.class, "table.tableName == t1 && table.database.name == t2");
       query.declareParameters("java.lang.String t1, java.lang.String t2");
       query.setOrdering("partitionName ascending");
-      if(max > 0) {
+      if (max > 0) {
         query.setRange(0, max);
       }
       mparts = (List<MPartition>) query.execute(tableName, dbName);
@@ -2214,8 +2275,8 @@ private boolean getPartitionNamesPrunedByExprNoTxn(Table table, byte[] expr,
   private List<Partition> getPartitionsViaOrmFilter(Table table, ExpressionTree tree,
       short maxParts, boolean isValidatedFilter) throws MetaException {
     Map<String, Object> params = new HashMap<String, Object>();
-    String jdoFilter = makeQueryFilterString(
-        table.getDbName(), table, tree, params, isValidatedFilter);
+    String jdoFilter =
+        makeQueryFilterString(table.getDbName(), table, tree, params, isValidatedFilter);
     if (jdoFilter == null) {
       assert !isValidatedFilter;
       return null;
@@ -2225,14 +2286,11 @@ private boolean getPartitionNamesPrunedByExprNoTxn(Table table, byte[] expr,
       // User specified a row limit, set it on the Query
       query.setRange(0, maxParts);
     }
-
     String parameterDeclaration = makeParameterDeclarationStringObj(params);
     query.declareParameters(parameterDeclaration);
     query.setOrdering("partitionName ascending");
-
     @SuppressWarnings("unchecked")
     List<MPartition> mparts = (List<MPartition>) query.executeWithMap(params);
-
     LOG.debug("Done executing query for getPartitionsViaOrmFilter");
     pm.retrieveAll(mparts); // TODO: why is this inconsistent with what we get by names?
     LOG.debug("Done retrieving all objects for getPartitionsViaOrmFilter");
@@ -2241,10 +2299,6 @@ private boolean getPartitionNamesPrunedByExprNoTxn(Table table, byte[] expr,
     return results;
   }
 
-  private static class Out<T> {
-    public T val;
-  }
-
   /**
    * Gets partition names from the table via ORM (JDOQL) name filter.
    * @param dbName Database name.
@@ -2257,16 +2311,19 @@ private boolean getPartitionNamesPrunedByExprNoTxn(Table table, byte[] expr,
     if (partNames.isEmpty()) {
       return new ArrayList<Partition>();
     }
-    Out<Query> query = new Out<Query>();
-    List<MPartition> mparts = null;
-    try {
-      mparts = getMPartitionsViaOrmFilter(dbName, tblName, partNames, query);
-      return convertToParts(dbName, tblName, mparts);
-    } finally {
-      if (query.val != null) {
-        query.val.closeAll();
-      }
+    ObjectPair<Query, Map<String, String>> queryWithParams =
+        getPartQueryWithParams(dbName, tblName, partNames);
+    Query query = queryWithParams.getFirst();
+    query.setResultClass(MPartition.class);
+    query.setClass(MPartition.class);
+    query.setOrdering("partitionName ascending");
+    @SuppressWarnings("unchecked")
+    List<MPartition> mparts = (List<MPartition>)query.executeWithMap(queryWithParams.getSecond());
+    List<Partition> partitions = convertToParts(dbName, tblName, mparts);
+    if (query != null) {
+      query.closeAll();
     }
+    return partitions;
   }
 
   private void dropPartitionsNoTxn(String dbName, String tblName, List<String> partNames) {
@@ -2302,27 +2359,15 @@ private void dropPartitionsNoTxn(String dbName, String tblName, List<String> par
         sd.setCD(null);
       }
     }
+    if (query != null) {
+      query.closeAll();
+    }
     return candidateCds;
   }
 
-  private List<MPartition> getMPartitionsViaOrmFilter(String dbName,
-      String tblName, List<String> partNames, Out<Query> out) {
-    ObjectPair<Query, Map<String, String>> queryWithParams =
-        getPartQueryWithParams(dbName, tblName, partNames);
-    Query query = out.val = queryWithParams.getFirst();
-    query.setResultClass(MPartition.class);
-    query.setClass(MPartition.class);
-    query.setOrdering("partitionName ascending");
-
-    @SuppressWarnings("unchecked")
-    List<MPartition> result = (List<MPartition>)query.executeWithMap(queryWithParams.getSecond());
-    return result;
-  }
-
-  private ObjectPair<Query, Map<String, String>> getPartQueryWithParams(
-      String dbName, String tblName, List<String> partNames) {
-    StringBuilder sb = new StringBuilder(
-        "table.tableName == t1 && table.database.name == t2 && (");
+  private ObjectPair<Query, Map<String, String>> getPartQueryWithParams(String dbName,
+      String tblName, List<String> partNames) {
+    StringBuilder sb = new StringBuilder("table.tableName == t1 && table.database.name == t2 && (");
     int n = 0;
     Map<String, String> params = new HashMap<String, String>();
     for (Iterator<String> itr = partNames.iterator(); itr.hasNext();) {
@@ -2335,16 +2380,13 @@ private void dropPartitionsNoTxn(String dbName, String tblName, List<String> par
     }
     sb.setLength(sb.length() - 4); // remove the last " || "
     sb.append(')');
-
     Query query = pm.newQuery();
     query.setFilter(sb.toString());
-
     LOG.debug(" JDOQL filter is " + sb.toString());
     params.put("t1", HiveStringUtils.normalizeIdentifier(tblName));
     params.put("t2", HiveStringUtils.normalizeIdentifier(dbName));
-
     query.declareParameters(makeParameterDeclarationString(params));
-    return new ObjectPair<Query, Map<String,String>>(query, params);
+    return new ObjectPair<Query, Map<String, String>>(query, params);
   }
 
   @Override
@@ -2666,6 +2708,7 @@ private String makeParameterDeclarationStringObj(Map<String, Object> params) {
   public List<String> listTableNamesByFilter(String dbName, String filter, short maxTables)
       throws MetaException {
     boolean success = false;
+    Query query = null;
     List<String> tableNames = new ArrayList<String>();
     try {
       openTransaction();
@@ -2673,7 +2716,7 @@ private String makeParameterDeclarationStringObj(Map<String, Object> params) {
       dbName = HiveStringUtils.normalizeIdentifier(dbName);
       Map<String, Object> params = new HashMap<String, Object>();
       String queryFilterString = makeQueryFilterString(dbName, null, filter, params);
-      Query query = pm.newQuery(MTable.class);
+      query = pm.newQuery(MTable.class);
       query.declareImports("import java.lang.String");
       query.setResult("tableName");
       query.setResultClass(java.lang.String.class);
@@ -2682,14 +2725,14 @@ private String makeParameterDeclarationStringObj(Map<String, Object> params) {
       }
       LOG.debug("filter specified is " + filter + "," + " JDOQL filter is " + queryFilterString);
       for (Entry<String, Object> entry : params.entrySet()) {
-        LOG.debug("key: " + entry.getKey() + " value: " + entry.getValue() +
-            " class: " + entry.getValue().getClass().getName());
+        LOG.debug("key: " + entry.getKey() + " value: " + entry.getValue() + " class: "
+            + entry.getValue().getClass().getName());
       }
       String parameterDeclaration = makeParameterDeclarationStringObj(params);
       query.declareParameters(parameterDeclaration);
       query.setFilter(queryFilterString);
-      Collection names = (Collection) query.executeWithMap(params);
-      //have to emulate "distinct", otherwise tables with the same name may be returned
+      Collection names = (Collection)query.executeWithMap(params);
+      // have to emulate "distinct", otherwise tables with the same name may be returned
       Set<String> tableNamesSet = new HashSet<String>();
       for (Iterator i = names.iterator(); i.hasNext();) {
         tableNamesSet.add((String) i.next());
@@ -2698,58 +2741,54 @@ private String makeParameterDeclarationStringObj(Map<String, Object> params) {
       LOG.debug("Done executing query for listTableNamesByFilter");
       success = commitTransaction();
       LOG.debug("Done retrieving all objects for listTableNamesByFilter");
-
     } finally {
       if (!success) {
         rollbackTransaction();
       }
+      if (query != null) {
+        query.closeAll();
+      }
     }
     return tableNames;
   }
 
   @Override
-  public List<String> listPartitionNamesByFilter(String dbName, String tableName,
-      String filter, short maxParts) throws MetaException {
+  public List<String> listPartitionNamesByFilter(String dbName, String tableName, String filter,
+      short maxParts) throws MetaException {
     boolean success = false;
+    Query query = null;
     List<String> partNames = new ArrayList<String>();
     try {
       openTransaction();
       LOG.debug("Executing listMPartitionNamesByFilter");
       dbName = HiveStringUtils.normalizeIdentifier(dbName);
       tableName = HiveStringUtils.normalizeIdentifier(tableName);
-
       MTable mtable = getMTable(dbName, tableName);
-      if( mtable == null ) {
+      if (mtable == null) {
         // To be consistent with the behavior of listPartitionNames, if the
         // table or db does not exist, we return an empty list
         return partNames;
       }
       Map<String, Object> params = new HashMap<String, Object>();
       String queryFilterString = makeQueryFilterString(dbName, mtable, filter, params);
-      Query query = pm.newQuery(
-          "select partitionName from org.apache.hadoop.hive.metastore.model.MPartition "
-          + "where " + queryFilterString);
-
-      if( maxParts >= 0 ) {
-        //User specified a row limit, set it on the Query
+      query =
+          pm.newQuery("select partitionName from org.apache.hadoop.hive.metastore.model.MPartition "
+              + "where " + queryFilterString);
+      if (maxParts >= 0) {
+        // User specified a row limit, set it on the Query
         query.setRange(0, maxParts);
       }
-
-      LOG.debug("Filter specified is " + filter + "," +
-          " JDOQL filter is " + queryFilterString);
+      LOG.debug("Filter specified is " + filter + "," + " JDOQL filter is " + queryFilterString);
       LOG.debug("Parms is " + params);
-
       String parameterDeclaration = makeParameterDeclarationStringObj(params);
       query.declareParameters(parameterDeclaration);
       query.setOrdering("partitionName ascending");
       query.setResult("partitionName");
-
       Collection names = (Collection) query.executeWithMap(params);
       partNames = new ArrayList<String>();
       for (Iterator i = names.iterator(); i.hasNext();) {
         partNames.add((String) i.next());
       }
-
       LOG.debug("Done executing query for listMPartitionNamesByFilter");
       success = commitTransaction();
       LOG.debug("Done retrieving all objects for listMPartitionNamesByFilter");
@@ -2757,6 +2796,9 @@ private String makeParameterDeclarationStringObj(Map<String, Object> params) {
       if (!success) {
         rollbackTransaction();
       }
+      if (query != null) {
+        query.closeAll();
+      }
     }
     return partNames;
   }
@@ -2960,10 +3002,12 @@ private void removeUnusedColumnDescriptor(MColumnDescriptor oldCD) {
     }
 
     boolean success = false;
+    QueryWrapper queryWrapper = new QueryWrapper();
+
     try {
       openTransaction();
       LOG.debug("execute removeUnusedColumnDescriptor");
-      List<MStorageDescriptor> referencedSDs = listStorageDescriptorsWithCD(oldCD, 1);
+      List<MStorageDescriptor> referencedSDs = listStorageDescriptorsWithCD(oldCD, 1, queryWrapper);
       //if no other SD references this CD, we can throw it out.
       if (referencedSDs != null && referencedSDs.isEmpty()) {
         pm.retrieve(oldCD);
@@ -2975,6 +3019,7 @@ private void removeUnusedColumnDescriptor(MColumnDescriptor oldCD) {
       if (!success) {
         rollbackTransaction();
       }
+      queryWrapper.close();
     }
   }
 
@@ -3003,21 +3048,22 @@ private void preDropStorageDescriptor(MStorageDescriptor msd) {
    * @param maxSDs the maximum number of SDs to return
    * @return a list of storage descriptors
    */
-  private List<MStorageDescriptor> listStorageDescriptorsWithCD(MColumnDescriptor oldCD,
-      long maxSDs) {
+  private List<MStorageDescriptor> listStorageDescriptorsWithCD(
+      MColumnDescriptor oldCD,
+      long maxSDs,
+      QueryWrapper queryWrapper) {
     boolean success = false;
     List<MStorageDescriptor> sds = null;
     try {
       openTransaction();
       LOG.debug("Executing listStorageDescriptorsWithCD");
-      Query query = pm.newQuery(MStorageDescriptor.class,
-          "this.cd == inCD");
+      Query query = queryWrapper.query = pm.newQuery(MStorageDescriptor.class, "this.cd == inCD");
       query.declareParameters("MColumnDescriptor inCD");
-      if(maxSDs >= 0) {
-        //User specified a row limit, set it on the Query
+      if (maxSDs >= 0) {
+        // User specified a row limit, set it on the Query
         query.setRange(0, maxSDs);
       }
-      sds = (List<MStorageDescriptor>) query.execute(oldCD);
+      sds = (List<MStorageDescriptor>)query.execute(oldCD);
       LOG.debug("Done executing query for listStorageDescriptorsWithCD");
       pm.retrieveAll(sds);
       success = commitTransaction();
@@ -3094,9 +3140,11 @@ public boolean dropIndex(String dbName, String origTableName, String indexName)
     return success;
   }
 
-  private MIndex getMIndex(String dbName, String originalTblName, String indexName) throws MetaException {
+  private MIndex getMIndex(String dbName, String originalTblName, String indexName)
+      throws MetaException {
     MIndex midx = null;
     boolean commited = false;
+    Query query = null;
     try {
       openTransaction();
       dbName = HiveStringUtils.normalizeIdentifier(dbName);
@@ -3106,19 +3154,23 @@ private MIndex getMIndex(String dbName, String originalTblName, String indexName
         commited = commitTransaction();
         return null;
       }
-
-      Query query = pm.newQuery(MIndex.class,
-        "origTable.tableName == t1 && origTable.database.name == t2 && indexName == t3");
+      query =
+          pm.newQuery(MIndex.class,
+              "origTable.tableName == t1 && origTable.database.name == t2 && indexName == t3");
       query.declareParameters("java.lang.String t1, java.lang.String t2, java.lang.String t3");
       query.setUnique(true);
-      midx = (MIndex) query.execute(originalTblName, dbName,
-          HiveStringUtils.normalizeIdentifier(indexName));
+      midx =
+          (MIndex) query.execute(originalTblName, dbName,
+              HiveStringUtils.normalizeIdentifier(indexName));
       pm.retrieve(midx);
       commited = commitTransaction();
     } finally {
       if (!commited) {
         rollbackTransaction();
       }
+      if (query != null) {
+        query.closeAll();
+      }
     }
     return midx;
   }
@@ -3159,64 +3211,55 @@ private Index convertToIndex(MIndex mIndex) throws MetaException {
   public List<Index> getIndexes(String dbName, String origTableName, int max)
       throws MetaException {
     boolean success = false;
+    Query query = null;
     try {
+      LOG.debug("Executing getIndexes");
       openTransaction();
-      List<MIndex> mIndexList = listMIndexes(dbName, origTableName, max);
-      List<Index> indexes = new ArrayList<Index>(mIndexList.size());
-      for (MIndex midx : mIndexList) {
-        indexes.add(this.convertToIndex(midx));
-      }
-      success = commitTransaction();
-      return indexes;
-    } finally {
-      if (!success) {
-        rollbackTransaction();
-      }
-    }
-  }
 
-  private List<MIndex> listMIndexes(String dbName, String origTableName,
-      int max) {
-    boolean success = false;
-    List<MIndex> mindexes = null;
-    try {
-      openTransaction();
-      LOG.debug("Executing listMIndexes");
       dbName = HiveStringUtils.normalizeIdentifier(dbName);
       origTableName = HiveStringUtils.normalizeIdentifier(origTableName);
-      Query query = pm.newQuery(MIndex.class,
-          "origTable.tableName == t1 && origTable.database.name == t2");
+      query =
+          pm.newQuery(MIndex.class, "origTable.tableName == t1 && origTable.database.name == t2");
       query.declareParameters("java.lang.String t1, java.lang.String t2");
-      mindexes = (List<MIndex>) query.execute(origTableName, dbName);
-      LOG.debug("Done executing query for listMIndexes");
-      pm.retrieveAll(mindexes);
+      List<MIndex> mIndexes = (List<MIndex>) query.execute(origTableName, dbName);
+      pm.retrieveAll(mIndexes);
+
+      List<Index> indexes = new ArrayList<Index>(mIndexes.size());
+      for (MIndex mIdx : mIndexes) {
+        indexes.add(this.convertToIndex(mIdx));
+      }
       success = commitTransaction();
-      LOG.debug("Done retrieving all objects for listMIndexes");
+      LOG.debug("Done retrieving all objects for getIndexes");
+
+      return indexes;
     } finally {
       if (!success) {
         rollbackTransaction();
       }
+      if (query != null) {
+        query.closeAll();
+      }
     }
-    return mindexes;
   }
 
   @Override
-  public List<String> listIndexNames(String dbName, String origTableName,
-      short max) throws MetaException {
+  public List<String> listIndexNames(String dbName, String origTableName, short max)
+      throws MetaException {
     List<String> pns = new ArrayList<String>();
     boolean success = false;
+    Query query = null;
     try {
       openTransaction();
       LOG.debug("Executing listIndexNames");
       dbName = HiveStringUtils.normalizeIdentifier(dbName);
       origTableName = HiveStringUtils.normalizeIdentifier(origTableName);
-      Query q = pm.newQuery(
-          "select indexName from org.apache.hadoop.hive.metastore.model.MIndex "
-          + "where origTable.database.name == t1 && origTable.tableName == t2 "
-          + "order by indexName asc");
-      q.declareParameters("java.lang.String t1, java.lang.String t2");
-      q.setResult("indexName");
-      Collection names = (Collection) q.execute(dbName, origTableName);
+      query =
+          pm.newQuery("select indexName from org.apache.hadoop.hive.metastore.model.MIndex "
+              + "where origTable.database.name == t1 && origTable.tableName == t2 "
+              + "order by indexName asc");
+      query.declareParameters("java.lang.String t1, java.lang.String t2");
+      query.setResult("indexName");
+      Collection names = (Collection) query.execute(dbName, origTableName);
       for (Iterator i = names.iterator(); i.hasNext();) {
         pns.add((String) i.next());
       }
@@ -3225,6 +3268,9 @@ private Index convertToIndex(MIndex mIndex) throws MetaException {
       if (!success) {
         rollbackTransaction();
       }
+      if (query != null) {
+        query.closeAll();
+      }
     }
     return pns;
   }
@@ -3241,8 +3287,7 @@ public boolean addRole(String roleName, String ownerName)
         throw new InvalidObjectException("Role " + roleName + " already exists.");
       }
       int now = (int)(System.currentTimeMillis()/1000);
-      MRole mRole = new MRole(roleName, now,
-          ownerName);
+      MRole mRole = new MRole(roleName, now, ownerName);
       pm.makePersistent(mRole);
       commited = commitTransaction();
       success = true;
@@ -3332,13 +3377,16 @@ public boolean revokeRole(Role role, String userName, PrincipalType principalTyp
     return success;
   }
 
-  private MRoleMap getMSecurityUserRoleMap(String userName,
-      PrincipalType principalType, String roleName) {
+  private MRoleMap getMSecurityUserRoleMap(String userName, PrincipalType principalType,
+      String roleName) {
     MRoleMap mRoleMember = null;
     boolean commited = false;
+    Query query = null;
     try {
       openTransaction();
-      Query query = pm.newQuery(MRoleMap.class, "principalName == t1 && principalType == t2 && role.roleName == t3");
+      query =
+          pm.newQuery(MRoleMap.class,
+              "principalName == t1 && principalType == t2 && role.roleName == t3");
       query.declareParameters("java.lang.String t1, java.lang.String t2, java.lang.String t3");
       query.setUnique(true);
       mRoleMember = (MRoleMap) query.executeWithArray(userName, principalType.toString(), roleName);
@@ -3348,6 +3396,9 @@ private MRoleMap getMSecurityUserRoleMap(String userName,
       if (!commited) {
         rollbackTransaction();
       }
+      if (query != null) {
+        query.closeAll();
+      }
     }
     return mRoleMember;
   }
@@ -3356,6 +3407,7 @@ private MRoleMap getMSecurityUserRoleMap(String userName,
   public boolean removeRole(String roleName) throws MetaException,
       NoSuchObjectException {
     boolean success = false;
+    QueryWrapper queryWrapper = new QueryWrapper();
     try {
       openTransaction();
       MRole mRol = getMRole(roleName);
@@ -3368,10 +3420,11 @@ public boolean removeRole(String roleName) throws MetaException,
           pm.deletePersistentAll(roleMap);
         }
         List<MRoleMap> roleMember = listMSecurityPrincipalMembershipRole(mRol
-            .getRoleName(), PrincipalType.ROLE);
+            .getRoleName(), PrincipalType.ROLE, queryWrapper);
         if (roleMember.size() > 0) {
           pm.deletePersistentAll(roleMember);
         }
+        queryWrapper.close();
         // then remove all the grants
         List<MGlobalPrivilege> userGrants = listPrincipalGlobalGrants(
             mRol.getRoleName(), PrincipalType.ROLE);
@@ -3379,30 +3432,36 @@ public boolean removeRole(String roleName) throws MetaException,
           pm.deletePersistentAll(userGrants);
         }
         List<MDBPrivilege> dbGrants = listPrincipalAllDBGrant(mRol
-            .getRoleName(), PrincipalType.ROLE);
+            .getRoleName(), PrincipalType.ROLE, queryWrapper);
         if (dbGrants.size() > 0) {
           pm.deletePersistentAll(dbGrants);
         }
+        queryWrapper.close();
         List<MTablePrivilege> tabPartGrants = listPrincipalAllTableGrants(
-            mRol.getRoleName(), PrincipalType.ROLE);
+            mRol.getRoleName(), PrincipalType.ROLE, queryWrapper);
         if (tabPartGrants.size() > 0) {
           pm.deletePersistentAll(tabPartGrants);
         }
+        queryWrapper.close();
         List<MPartitionPrivilege> partGrants = listPrincipalAllPartitionGrants(
-            mRol.getRoleName(), PrincipalType.ROLE);
+            mRol.getRoleName(), PrincipalType.ROLE, queryWrapper);
         if (partGrants.size() > 0) {
           pm.deletePersistentAll(partGrants);
         }
+        queryWrapper.close();
         List<MTableColumnPrivilege> tblColumnGrants = listPrincipalAllTableColumnGrants(
-            mRol.getRoleName(), PrincipalType.ROLE);
+            mRol.getRoleName(), PrincipalType.ROLE, queryWrapper);
         if (tblColumnGrants.size() > 0) {
           pm.deletePersistentAll(tblColumnGrants);
         }
+        queryWrapper.close();
         List<MPartitionColumnPrivilege> partColumnGrants = listPrincipalAllPartitionColumnGrants(
-            mRol.getRoleName(), PrincipalType.ROLE);
+            mRol.getRoleName(), PrincipalType.ROLE, queryWrapper);
         if (partColumnGrants.size() > 0) {
           pm.deletePersistentAll(partColumnGrants);
         }
+        queryWrapper.close();
+
         // finally remove the role
         pm.deletePersistent(mRol);
       }
@@ -3411,6 +3470,8 @@ public boolean removeRole(String roleName) throws MetaException,
       if (!success) {
         rollbackTransaction();
       }
+
+      queryWrapper.close();
     }
     return success;
   }
@@ -3459,66 +3520,62 @@ private void getAllRoleAncestors(Set<String> processedRoleNames, List<MRoleMap>
 
   @SuppressWarnings("unchecked")
   @Override
-  public List<MRoleMap> listRoles(String principalName,
-      PrincipalType principalType) {
+  public List<MRoleMap> listRoles(String principalName, PrincipalType principalType) {
     boolean success = false;
-    List<MRoleMap> mRoleMember = null;
+    Query query = null;
+    List<MRoleMap> mRoleMember = new ArrayList<MRoleMap>();
+
     try {
-      openTransaction();
       LOG.debug("Executing listRoles");
-      Query query = pm
-          .newQuery(
-              MRoleMap.class,
-              "principalName == t1 && principalType == t2");
-      query
-          .declareParameters("java.lang.String t1, java.lang.String t2");
+
+      openTransaction();
+      query = pm.newQuery(MRoleMap.class, "principalName == t1 && principalType == t2");
+      query.declareParameters("java.lang.String t1, java.lang.String t2");
       query.setUnique(false);
-      mRoleMember = (List<MRoleMap>) query.executeWithArray(
-          principalName, principalType.toString());
-      LOG.debug("Done executing query for listMSecurityUserRoleMap");
-      pm.retrieveAll(mRoleMember);
+      List<MRoleMap> mRoles =
+          (List<MRoleMap>) query.executeWithArray(principalName, principalType.toString());
+      pm.retrieveAll(mRoles);
       success = commitTransaction();
-      LOG.debug("Done retrieving all objects for listMSecurityUserRoleMap");
+
+      mRoleMember.addAll(mRoles);
+
+      LOG.debug("Done retrieving all objects for listRoles");
     } finally {
       if (!success) {
         rollbackTransaction();
       }
+      if (query != null) {
+        query.closeAll();
+      }
     }
 
     if (principalType == PrincipalType.USER) {
       // All users belong to public role implicitly, add that role
-      if (mRoleMember == null) {
-        mRoleMember = new ArrayList<MRoleMap>();
-      } else {
-        mRoleMember = new ArrayList<MRoleMap>(mRoleMember);
-      }
       MRole publicRole = new MRole(HiveMetaStore.PUBLIC, 0, HiveMetaStore.PUBLIC);
-      mRoleMember.add(new MRoleMap(principalName, principalType.toString(), publicRole, 0,
-          null, null, false));
+      mRoleMember.add(new MRoleMap(principalName, principalType.toString(), publicRole, 0, null,
+          null, false));
     }
-    return mRoleMember;
 
+    return mRoleMember;
   }
 
   @SuppressWarnings("unchecked")
   private List<MRoleMap> listMSecurityPrincipalMembershipRole(final String roleName,
-      final PrincipalType principalType) {
+      final PrincipalType principalType,
+      QueryWrapper queryWrapper) {
     boolean success = false;
     List<MRoleMap> mRoleMemebership = null;
     try {
-      openTransaction();
       LOG.debug("Executing listMSecurityPrincipalMembershipRole");
-      Query query = pm.newQuery(MRoleMap.class,
-          "principalName == t1 && principalType == t2");
-      query
-          .declareParameters("java.lang.String t1, java.lang.String t2");
+
+      openTransaction();
+      Query query = queryWrapper.query = pm.newQuery(MRoleMap.class, "principalName == t1 && principalType == t2");
+      query.declareParameters("java.lang.String t1, java.lang.String t2");
       mRoleMemebership = (List<MRoleMap>) query.execute(roleName, principalType.toString());
-      LOG
-          .debug("Done executing query for listMSecurityPrincipalMembershipRole");
       pm.retrieveAll(mRoleMemebership);
       success = commitTransaction();
-      LOG
-          .debug("Done retrieving all objects for listMSecurityPrincipalMembershipRole");
+
+      LOG.debug("Done retrieving all objects for listMSecurityPrincipalMembershipRole");
     } finally {
       if (!success) {
         rollbackTransaction();
@@ -3541,9 +3598,10 @@ public Role getRole(String roleName) throws NoSuchObjectException {
   private MRole getMRole(String roleName) {
     MRole mrole = null;
     boolean commited = false;
+    Query query = null;
     try {
       openTransaction();
-      Query query = pm.newQuery(MRole.class, "roleName == t1");
+      query = pm.newQuery(MRole.class, "roleName == t1");
       query.declareParameters("java.lang.String t1");
       query.setUnique(true);
       mrole = (MRole) query.execute(roleName);
@@ -3553,6 +3611,9 @@ private MRole getMRole(String roleName) {
       if (!commited) {
         rollbackTransaction();
       }
+      if (query != null) {
+        query.closeAll();
+      }
     }
     return mrole;
   }
@@ -3560,13 +3621,14 @@ private MRole getMRole(String roleName) {
   @Override
   public List<String> listRoleNames() {
     boolean success = false;
+    Query query = null;
     try {
       openTransaction();
       LOG.debug("Executing listAllRoleNames");
-      Query query = pm.newQuery("select roleName from org.apache.hadoop.hive.metastore.model.MRole");
+      query = pm.newQuery("select roleName from org.apache.hadoop.hive.metastore.model.MRole");
       query.setResult("roleName");
       Collection names = (Collection) query.execute();
-      List<String> roleNames  = new ArrayList<String>();
+      List<String> roleNames = new ArrayList<String>();
       for (Iterator i = names.iterator(); i.hasNext();) {
         roleNames.add((String) i.next());
       }
@@ -3576,6 +3638,9 @@ private MRole getMRole(String roleName) {
       if (!success) {
         rollbackTransaction();
       }
+      if (query != null) {
+        query.closeAll();
+      }
     }
   }
 
@@ -4384,49 +4449,61 @@ public boolean revokePrivileges(PrivilegeBag privileges, boolean grantOption)
   @Override
   public List<MRoleMap> listRoleMembers(String roleName) {
     boolean success = false;
-    List<MRoleMap> mRoleMemeberList = null;
+    Query query = null;
+    List<MRoleMap> mRoleMemeberList = new ArrayList<MRoleMap>();
     try {
+      LOG.debug("Executing listRoleMembers");
+
       openTransaction();
-      LOG.debug("Executing listMSecurityUserRoleMember");
-      Query query = pm.newQuery(MRoleMap.class,
-          "role.roleName == t1");
+      query = pm.newQuery(MRoleMap.class, "role.roleName == t1");
       query.declareParameters("java.lang.String t1");
       query.setUnique(false);
-      mRoleMemeberList = (List<MRoleMap>) query.execute(
-          roleName);
-      LOG.debug("Done executing query for listMSecurityUserRoleMember");
-      pm.retrieveAll(mRoleMemeberList);
+      List<MRoleMap> mRoles = (List<MRoleMap>) query.execute(roleName);
+      pm.retrieveAll(mRoles);
       success = commitTransaction();
-      LOG.debug("Done retrieving all objects for listMSecurityUserRoleMember");
+
+      mRoleMemeberList.addAll(mRoles);
+
+      LOG.debug("Done retrieving all objects for listRoleMembers");
     } finally {
       if (!success) {
         rollbackTransaction();
       }
+      if (query != null) {
+        query.closeAll();
+      }
     }
     return mRoleMemeberList;
   }
 
   @SuppressWarnings("unchecked")
   @Override
-  public List<MGlobalPrivilege> listPrincipalGlobalGrants(String principalName, PrincipalType principalType) {
+  public List<MGlobalPrivilege> listPrincipalGlobalGrants(String principalName,
+      PrincipalType principalType) {
     boolean commited = false;
-    List<MGlobalPrivilege> userNameDbPriv = null;
+    Query query = null;
+    List<MGlobalPrivilege> userNameDbPriv = new ArrayList<MGlobalPrivilege>();
     try {
+      List<MGlobalPrivilege> mPrivs = null;
       openTransaction();
       if (principalName != null) {
-        Query query = pm.newQuery(MGlobalPrivilege.class,
-            "principalName == t1 && principalType == t2 ");
-        query.declareParameters(
-            "java.lang.String t1, java.lang.String t2");
-        userNameDbPriv = (List<MGlobalPrivilege>) query
-            .executeWithArray(principalName, principalType.toString());
-        pm.retrieveAll(userNameDbPriv);
+        query = pm.newQuery(MGlobalPrivilege.class, "principalName == t1 && principalType == t2 ");
+        query.declareParameters("java.lang.String t1, java.lang.String t2");
+        mPrivs = (List<MGlobalPrivilege>) query
+                .executeWithArray(principalName, principalType.toString());
+        pm.retrieveAll(mPrivs);
       }
       commited = commitTransaction();
+      if (mPrivs != null) {
+        userNameDbPriv.addAll(mPrivs);
+      }
     } finally {
       if (!commited) {
         rollbackTransaction();
       }
+      if (query != null) {
+        query.closeAll();
+      }
     }
     return userNameDbPriv;
   }
@@ -4434,9 +4511,10 @@ public boolean revokePrivileges(PrivilegeBag privileges, boolean grantOption)
   @Override
   public List<HiveObjectPrivilege> listGlobalGrantsAll() {
     boolean commited = false;
+    Query query = null;
     try {
       openTransaction();
-      Query query = pm.newQuery(MGlobalPrivilege.class);
+      query = pm.newQuery(MGlobalPrivilege.class);
       List<MGlobalPrivilege> userNameDbPriv = (List<MGlobalPrivilege>) query.execute();
       pm.retrieveAll(userNameDbPriv);
       commited = commitTransaction();
@@ -4445,6 +4523,9 @@ public boolean revokePrivileges(PrivilegeBag privileges, boolean grantOption)
       if (!commited) {
         rollbackTransaction();
       }
+      if (query != null) {
+        query.closeAll();
+      }
     }
   }
 
@@ -4468,25 +4549,32 @@ public boolean revokePrivileges(PrivilegeBag privileges, boolean grantOption)
   public List<MDBPrivilege> listPrincipalDBGrants(String principalName,
       PrincipalType principalType, String dbName) {
     boolean success = false;
-    List<MDBPrivilege> mSecurityDBList = null;
+    Query query = null;
+    List<MDBPrivilege> mSecurityDBList = new ArrayList<MDBPrivilege>();
     dbName = HiveStringUtils.normalizeIdentifier(dbName);
-
     try {
-      openTransaction();
       LOG.debug("Executing listPrincipalDBGrants");
-        Query query = pm.newQuery(MDBPrivilege.class,
-            "principalName == t1 && principalType == t2 && database.name == t3");
-        query
-            .declareParameters("java.lang.String t1, java.lang.String t2, java.lang.String t3");
-        mSecurityDBList = (List<MDBPrivilege>) query.executeWithArray(principalName, principalType.toString(), dbName);
-      LOG.debug("Done executing query for listPrincipalDBGrants");
-      pm.retrieveAll(mSecurityDBList);
+
+      openTransaction();
+      query =
+          pm.newQuery(MDBPrivilege.class,
+              "principalName == t1 && principalType == t2 && database.name == t3");
+      query.declareParameters("java.lang.String t1, java.lang.String t2, java.lang.String t3");
+      List<MDBPrivilege> mPrivs =
+          (List<MDBPrivilege>) query.executeWithArray(principalName, principalType.toString(),
+              dbName);
+      pm.retrieveAll(mPrivs);
       success = commitTransaction();
+
+      mSecurityDBList.addAll(mPrivs);
       LOG.debug("Done retrieving all objects for listPrincipalDBGrants");
     } finally {
       if (!success) {
         rollbackTransaction();
       }
+      if (query != null) {
+        query.closeAll();
+      }
     }
     return mSecurityDBList;
   }
@@ -4494,12 +4582,22 @@ public boolean revokePrivileges(PrivilegeBag privileges, boolean grantOption)
   @Override
   public List<HiveObjectPrivilege> listPrincipalDBGrantsAll(
       String principalName, PrincipalType principalType) {
-    return convertDB(listPrincipalAllDBGrant(principalName, principalType));
+    QueryWrapper queryWrapper = new QueryWrapper();
+    try {
+      return convertDB(listPrincipalAllDBGrant(principalName, principalType, queryWrapper));
+    } finally {
+      queryWrapper.close();
+    }
   }
 
   @Override
   public List<HiveObjectPrivilege> listDBGrantsAll(String dbName) {
-    return convertDB(listDatabaseGrants(dbName));
+    QueryWrapper queryWrapper = new QueryWrapper();
+    try {
+      return convertDB(listDatabaseGrants(dbName, queryWrapper));
+      } finally {
+        queryWrapper.close();
+      }
   }
 
   private List<HiveObjectPrivilege> convertDB(List<MDBPrivilege> privs) {
@@ -4520,26 +4618,28 @@ public boolean revokePrivileges(PrivilegeBag privileges, boolean grantOption)
   }
 
   @SuppressWarnings("unchecked")
-  private List<MDBPrivilege> listPrincipalAllDBGrant(
-      String principalName, PrincipalType principalType) {
+  private List<MDBPrivilege> listPrincipalAllDBGrant(String principalName,
+      PrincipalType principalType,
+      QueryWrapper queryWrapper) {
     boolean success = false;
+    Query query = null;
     List<MDBPrivilege> mSecurityDBList = null;
     try {
-      openTransaction();
       LOG.debug("Executing listPrincipalAllDBGrant");
+
+      openTransaction();
       if (principalName != null && principalType != null) {
-        Query query = pm.newQuery(MDBPrivilege.class,
-            "principalName == t1 && principalType == t2");
-        query
-            .declareParameters("java.lang.String t1, java.lang.String t2");
-        mSecurityDBList = (List<MDBPrivilege>) query.execute(principalName, principalType.toString());
+        query = queryWrapper.query = pm.newQuery(MDBPrivilege.class, "principalName == t1 && principalType == t2");
+        query.declareParameters("java.lang.String t1, java.lang.String t2");
+        mSecurityDBList =
+            (List<MDBPrivilege>) query.execute(principalName, principalType.toString());
       } else {
-        Query query = pm.newQuery(MDBPrivilege.class);
+        query = queryWrapper.query = pm.newQuery(MDBPrivilege.class);
         mSecurityDBList = (List<MDBPrivilege>) query.execute();
       }
-      LOG.debug("Done executing query for listPrincipalAllDBGrant");
       pm.retrieveAll(mSecurityDBList);
       success = commitTransaction();
+
       LOG.debug("Done retrieving all objects for listPrincipalAllDBGrant");
     } finally {
       if (!success) {
@@ -4550,91 +4650,101 @@ public boolean revokePrivileges(PrivilegeBag privileges, boolean grantOption)
   }
 
   @SuppressWarnings("unchecked")
-  public List<MTablePrivilege> listAllTableGrants(String dbName,
-      String tableName) {
+  public List<MTablePrivilege> listAllTableGrants(String dbName, String tableName) {
     boolean success = false;
+    Query query = null;
     tableName = HiveStringUtils.normalizeIdentifier(tableName);
     dbName = HiveStringUtils.normalizeIdentifier(dbName);
-    List<MTablePrivilege> mSecurityTabList = null;
+    List<MTablePrivilege> mSecurityTabList = new ArrayList<MTablePrivilege>();
     tableName = HiveStringUtils.normalizeIdentifier(tableName);
     dbName = HiveStringUtils.normalizeIdentifier(dbName);
     try {
-      openTransaction();
       LOG.debug("Executing listAllTableGrants");
+
+      openTransaction();
       String queryStr = "table.tableName == t1 && table.database.name == t2";
-      Query query = pm.newQuery(
-          MTablePrivilege.class, queryStr);
-      query.declareParameters(
-          "java.lang.String t1, java.lang.String t2");
-      mSecurityTabList = (List<MTablePrivilege>) query
-          .executeWithArray(tableName, dbName);
+      query = pm.newQuery(MTablePrivilege.class, queryStr);
+      query.declareParameters("java.lang.String t1, java.lang.String t2");
+      List<MTablePrivilege> mPrivs  = (List<MTablePrivilege>) query.executeWithArray(tableName, dbName);
       LOG.debug("Done executing query for listAllTableGrants");
-      pm.retrieveAll(mSecurityTabList);
+      pm.retrieveAll(mPrivs);
       success = commitTransaction();
-      LOG
-          .debug("Done retrieving all objects for listAllTableGrants");
+
+      mSecurityTabList.addAll(mPrivs);
+
+      LOG.debug("Done retrieving all objects for listAllTableGrants");
     } finally {
       if (!success) {
         rollbackTransaction();
       }
+      if (query != null) {
+        query.closeAll();
+      }
     }
     return mSecurityTabList;
   }
 
   @SuppressWarnings("unchecked")
-  public List<MPartitionPrivilege> listTableAllPartitionGrants(String dbName,
-      String tableName) {
+  public List<MPartitionPrivilege> listTableAllPartitionGrants(String dbName, String tableName) {
     tableName = HiveStringUtils.normalizeIdentifier(tableName);
     dbName = HiveStringUtils.normalizeIdentifier(dbName);
     boolean success = false;
-    List<MPartitionPrivilege> mSecurityTabPartList = null;
+    Query query = null;
+    List<MPartitionPrivilege> mSecurityTabPartList = new ArrayList<MPartitionPrivilege>();
     try {
-      openTransaction();
       LOG.debug("Executing listTableAllPartitionGrants");
+
+      openTransaction();
       String queryStr = "partition.table.tableName == t1 && partition.table.database.name == t2";
-      Query query = pm.newQuery(
-          MPartitionPrivilege.class, queryStr);
-      query.declareParameters(
-          "java.lang.String t1, java.lang.String t2");
-      mSecurityTabPartList = (List<MPartitionPrivilege>) query
-          .executeWithArray(tableName, dbName);
-      LOG.debug("Done executing query for listTableAllPartitionGrants");
-      pm.retrieveAll(mSecurityTabPartList);
+      query = pm.newQuery(MPartitionPrivilege.class, queryStr);
+      query.declareParameters("java.lang.String t1, java.lang.String t2");
+      List<MPartitionPrivilege> mPrivs = (List<MPartitionPrivilege>) query.executeWithArray(tableName, dbName);
+      pm.retrieveAll(mPrivs);
       success = commitTransaction();
-      LOG
-          .debug("Done retrieving all objects for listTableAllPartitionGrants");
+
+      mSecurityTabPartList.addAll(mPrivs);
+
+      LOG.debug("Done retrieving all objects for listTableAllPartitionGrants");
     } finally {
       if (!success) {
         rollbackTransaction();
       }
+      if (query != null) {
+        query.closeAll();
+      }
     }
     return mSecurityTabPartList;
   }
 
   @SuppressWarnings("unchecked")
-  public List<MTableColumnPrivilege> listTableAllColumnGrants(String dbName,
-      String tableName) {
+  public List<MTableColumnPrivilege> listTableAllColumnGrants(String dbName, String tableName) {
     boolean success = false;
-    List<MTableColumnPrivilege> mTblColPrivilegeList = null;
+    Query query = null;
+    List<MTableColumnPrivilege> mTblColPrivilegeList = new ArrayList<MTableColumnPrivilege>();
     tableName = HiveStringUtils.normalizeIdentifier(tableName);
     dbName = HiveStringUtils.normalizeIdentifier(dbName);
-
     try {
-      openTransaction();
       LOG.debug("Executing listTableAllColumnGrants");
+
+      openTransaction();
       String queryStr = "table.tableName == t1 && table.database.name == t2";
-      Query query = pm.newQuery(MTableColumnPrivilege.class, queryStr);
+      query = pm.newQuery(MTableColumnPrivilege.class, queryStr);
       query.declareParameters("java.lang.String t1, java.lang.String t2");
-      mTblColPrivilegeList = (List<MTableColumnPrivilege>) query
-          .executeWithArray(tableName, dbName);
-      LOG.debug("Done executing query for listTableAllColumnGrants");
-      pm.retrieveAll(mTblColPrivilegeList);
+      List<MTableColumnPrivilege> mPrivs =
+          (List<MTableColumnPrivilege>) query.executeWithArray(tableName, dbName);
+      pm.retrieveAll(mPrivs);
       success = commitTransaction();
+
+      mTblColPrivilegeList.addAll(mPrivs);
+
       LOG.debug("Done retrieving all objects for listTableAllColumnGrants");
     } finally {
       if (!success) {
         rollbackTransaction();
       }
+      if (query != null) {
+        query.closeAll();
+      }
     }
     return mTblColPrivilegeList;
   }
@@ -4643,26 +4753,32 @@ public boolean revokePrivileges(PrivilegeBag privileges, boolean grantOption)
   public List<MPartitionColumnPrivilege> listTableAllPartitionColumnGrants(String dbName,
       String tableName) {
     boolean success = false;
+    Query query = null;
     tableName = HiveStringUtils.normalizeIdentifier(tableName);
     dbName = HiveStringUtils.normalizeIdentifier(dbName);
-
-    List<MPartitionColumnPrivilege> mSecurityColList = null;
+    List<MPartitionColumnPrivilege> mSecurityColList = new ArrayList<MPartitionColumnPrivilege>();
     try {
-      openTransaction();
       LOG.debug("Executing listTableAllPartitionColumnGrants");
+
+      openTransaction();
       String queryStr = "partition.table.tableName == t1 && partition.table.database.name == t2";
-      Query query = pm.newQuery(MPartitionColumnPrivilege.class, queryStr);
+      query = pm.newQuery(MPartitionColumnPrivilege.class, queryStr);
       query.declareParameters("java.lang.String t1, java.lang.String t2");
-      mSecurityColList = (List<MPartitionColumnPrivilege>) query
-          .executeWithArray(tableName, dbName);
-      LOG.debug("Done executing query for listTableAllPartitionColumnGrants");
-      pm.retrieveAll(mSecurityColList);
+      List<MPartitionColumnPrivilege> mPrivs =
+          (List<MPartitionColumnPrivilege>) query.executeWithArray(tableName, dbName);
+      pm.retrieveAll(mPrivs);
       success = commitTransaction();
+
+      mSecurityColList.addAll(mPrivs);
+
       LOG.debug("Done retrieving all objects for listTableAllPartitionColumnGrants");
     } finally {
       if (!success) {
         rollbackTransaction();
       }
+      if (query != null) {
+        query.closeAll();
+      }
     }
     return mSecurityColList;
   }
@@ -4702,19 +4818,17 @@ public void dropPartitionAllColumnGrantsNoTxn(
   }
 
   @SuppressWarnings("unchecked")
-  private List<MDBPrivilege> listDatabaseGrants(String dbName) {
+  private List<MDBPrivilege> listDatabaseGrants(String dbName, QueryWrapper queryWrapper) {
     dbName = HiveStringUtils.normalizeIdentifier(dbName);
-
     boolean success = false;
+
     try {
-      openTransaction();
       LOG.debug("Executing listDatabaseGrants");
-      Query query = pm.newQuery(MDBPrivilege.class,
-          "database.name == t1");
+
+      openTransaction();
+      Query query = queryWrapper.query = pm.newQuery(MDBPrivilege.class, "database.name == t1");
       query.declareParameters("java.lang.String t1");
-      List<MDBPrivilege> mSecurityDBList = (List<MDBPrivilege>) query
-          .executeWithArray(dbName);
-      LOG.debug("Done executing query for listDatabaseGrants");
+      List<MDBPrivilege> mSecurityDBList = (List<MDBPrivilege>) query.executeWithArray(dbName);
       pm.retrieveAll(mSecurityDBList);
       success = commitTransaction();
       LOG.debug("Done retrieving all objects for listDatabaseGrants");
@@ -4790,162 +4904,181 @@ private void dropPartitionGrantsNoTxn(String dbName, String tableName, List<Stri
 
   @Override
   @SuppressWarnings("unchecked")
-  public List<MTablePrivilege> listAllTableGrants(
-      String principalName, PrincipalType principalType, String dbName,
-      String tableName) {
+  public List<MTablePrivilege> listAllTableGrants(String principalName,
+      PrincipalType principalType, String dbName, String tableName) {
     tableName = HiveStringUtils.normalizeIdentifier(tableName);
     dbName = HiveStringUtils.normalizeIdentifier(dbName);
-
     boolean success = false;
-    List<MTablePrivilege> mSecurityTabPartList = null;
+    Query query = null;
+    List<MTablePrivilege> mSecurityTabPartList = new ArrayList<MTablePrivilege>();
     try {
       openTransaction();
       LOG.debug("Executing listAllTableGrants");
-      Query query = pm.newQuery(
-          MTablePrivilege.class,
+      query =
+          pm.newQuery(MTablePrivilege.class,
               "principalName == t1 && principalType == t2 && table.tableName == t3 && table.database.name == t4");
-      query.declareParameters(
-          "java.lang.String t1, java.lang.String t2, java.lang.String t3, java.lang.String t4");
-      mSecurityTabPartList = (List<MTablePrivilege>) query
-          .executeWithArray(principalName, principalType.toString(), tableName, dbName);
-      LOG.debug("Done executing query for listAllTableGrants");
-      pm.retrieveAll(mSecurityTabPartList);
+      query
+          .declareParameters("java.lang.String t1, java.lang.String t2, java.lang.String t3, java.lang.String t4");
+      List<MTablePrivilege> mPrivs =
+          (List<MTablePrivilege>) query.executeWithArray(principalName, principalType.toString(),
+              tableName, dbName);
+      pm.retrieveAll(mPrivs);
       success = commitTransaction();
-      LOG
-          .debug("Done retrieving all objects for listAllTableGrants");
+
+      mSecurityTabPartList.addAll(mPrivs);
+
+      LOG.debug("Done retrieving all objects for listAllTableGrants");
     } finally {
       if (!success) {
         rollbackTransaction();
       }
+      if (query != null) {
+        query.closeAll();
+      }
     }
     return mSecurityTabPartList;
   }
 
   @SuppressWarnings("unchecked")
   @Override
-  public List<MPartitionPrivilege> listPrincipalPartitionGrants(
-      String principalName, PrincipalType principalType, String dbName,
-      String tableName, String partName) {
+  public List<MPartitionPrivilege> listPrincipalPartitionGrants(String principalName,
+      PrincipalType principalType, String dbName, String tableName, String partName) {
     boolean success = false;
+    Query query = null;
     tableName = HiveStringUtils.normalizeIdentifier(tableName);
     dbName = HiveStringUtils.normalizeIdentifier(dbName);
-
-    List<MPartitionPrivilege> mSecurityTabPartList = null;
+    List<MPartitionPrivilege> mSecurityTabPartList = new ArrayList<MPartitionPrivilege>();
     try {
-      openTransaction();
-      LOG.debug("Executing listMSecurityPrincipalPartitionGrant");
-      Query query = pm.newQuery(
-          MPartitionPrivilege.class,
-              "principalName == t1 && principalType == t2 && partition.table.tableName == t3 " +
-              "&& partition.table.database.name == t4 && partition.partitionName == t5");
-      query.declareParameters(
-          "java.lang.String t1, java.lang.String t2, java.lang.String t3, java.lang.String t4, " +
-          "java.lang.String t5");
-      mSecurityTabPartList = (List<MPartitionPrivilege>) query
-          .executeWithArray(principalName, principalType.toString(), tableName, dbName, partName);
-      LOG.debug("Done executing query for listMSecurityPrincipalPartitionGrant");
+      LOG.debug("Executing listPrincipalPartitionGrants");
 
-      pm.retrieveAll(mSecurityTabPartList);
+      openTransaction();
+      query =
+          pm.newQuery(MPartitionPrivilege.class,
+              "principalName == t1 && principalType == t2 && partition.table.tableName == t3 "
+                  + "&& partition.table.database.name == t4 && partition.partitionName == t5");
+      query
+          .declareParameters("java.lang.String t1, java.lang.String t2, java.lang.String t3, java.lang.String t4, "
+              + "java.lang.String t5");
+      List<MPartitionPrivilege> mPrivs =
+          (List<MPartitionPrivilege>) query.executeWithArray(principalName,
+              principalType.toString(), tableName, dbName, partName);
+      pm.retrieveAll(mPrivs);
       success = commitTransaction();
-      LOG.debug("Done retrieving all objects for listMSecurityPrincipalPartitionGrant");
+
+      mSecurityTabPartList.addAll(mPrivs);
+
+      LOG.debug("Done retrieving all objects for listPrincipalPartitionGrants");
     } finally {
       if (!success) {
         rollbackTransaction();
       }
+      if (query != null) {
+        query.closeAll();
+      }
     }
     return mSecurityTabPartList;
   }
 
   @SuppressWarnings("unchecked")
   @Override
-  public List<MTableColumnPrivilege> listPrincipalTableColumnGrants(
-      String principalName, PrincipalType principalType, String dbName,
-      String tableName, String columnName) {
+  public List<MTableColumnPrivilege> listPrincipalTableColumnGrants(String principalName,
+      PrincipalType principalType, String dbName, String tableName, String columnName) {
     boolean success = false;
+    Query query = null;
     tableName = HiveStringUtils.normalizeIdentifier(tableName);
     dbName = HiveStringUtils.normalizeIdentifier(dbName);
     columnName = HiveStringUtils.normalizeIdentifier(columnName);
-    List<MTableColumnPrivilege> mSecurityColList = null;
+    List<MTableColumnPrivilege> mSecurityColList = new ArrayList<MTableColumnPrivilege>();
     try {
-      openTransaction();
       LOG.debug("Executing listPrincipalTableColumnGrants");
-      String queryStr = "principalName == t1 && principalType == t2 && " +
-          "table.tableName == t3 && table.database.name == t4 &&  columnName == t5 ";
-      Query query = pm.newQuery(MTableColumnPrivilege.class, queryStr);
-      query
-          .declareParameters("java.lang.String t1, java.lang.String t2, java.lang.String t3, " +
-              "java.lang.String t4, java.lang.String t5");
-      mSecurityColList = (List<MTableColumnPrivilege>) query.executeWithArray(
-          principalName, principalType.toString(), tableName, dbName, columnName);
-      LOG.debug("Done executing query for listPrincipalTableColumnGrants");
-      pm.retrieveAll(mSecurityColList);
+
+      openTransaction();
+      String queryStr =
+          "principalName == t1 && principalType == t2 && "
+              + "table.tableName == t3 && table.database.name == t4 &&  columnName == t5 ";
+      query = pm.newQuery(MTableColumnPrivilege.class, queryStr);
+      query.declareParameters("java.lang.String t1, java.lang.String t2, java.lang.String t3, "
+          + "java.lang.String t4, java.lang.String t5");
+      List<MTableColumnPrivilege> mPrivs =
+          (List<MTableColumnPrivilege>) query.executeWithArray(principalName,
+              principalType.toString(), tableName, dbName, columnName);
+      pm.retrieveAll(mPrivs);
       success = commitTransaction();
-      LOG
-          .debug("Done retrieving all objects for listPrincipalTableColumnGrants");
+
+      mSecurityColList.addAll(mPrivs);
+
+      LOG.debug("Done retrieving all objects for listPrincipalTableColumnGrants");
     } finally {
       if (!success) {
         rollbackTransaction();
       }
+      if (query != null) {
+        query.closeAll();
+      }
     }
     return mSecurityColList;
   }
 
   @Override
   @SuppressWarnings("unchecked")
-  public List<MPartitionColumnPrivilege> listPrincipalPartitionColumnGrants(
-      String principalName, PrincipalType principalType, String dbName,
-      String tableName, String partitionName, String columnName) {
+  public List<MPartitionColumnPrivilege> listPrincipalPartitionColumnGrants(String principalName,
+      PrincipalType principalType, String dbName, String tableName, String partitionName,
+      String columnName) {
     boolean success = false;
+    Query query = null;
     tableName = HiveStringUtils.normalizeIdentifier(tableName);
     dbName = HiveStringUtils.normalizeIdentifier(dbName);
     columnName = HiveStringUtils.normalizeIdentifier(columnName);
-
-    List<MPartitionColumnPrivilege> mSecurityColList = null;
+    List<MPartitionColumnPrivilege> mSecurityColList = new ArrayList<MPartitionColumnPrivilege>();
     try {
-      openTransaction();
       LOG.debug("Executing listPrincipalPartitionColumnGrants");
-      Query query = pm
-          .newQuery(
+
+      openTransaction();
+      query = pm.newQuery(
               MPartitionColumnPrivilege.class,
-              "principalName == t1 && principalType == t2 && partition.table.tableName == t3 " +
-              "&& partition.table.database.name == t4 && partition.partitionName == t5 && columnName == t6");
-      query
-          .declareParameters("java.lang.String t1, java.lang.String t2, java.lang.String t3, " +
-              "java.lang.String t4, java.lang.String t5, java.lang.String t6");
+              "principalName == t1 && principalType == t2 && partition.table.tableName == t3 "
+                  + "&& partition.table.database.name == t4 && partition.partitionName == t5 && columnName == t6");
+      query.declareParameters("java.lang.String t1, java.lang.String t2, java.lang.String t3, "
+          + "java.lang.String t4, java.lang.String t5, java.lang.String t6");
+      List<MPartitionColumnPrivilege> mPrivs =
+          (List<MPartitionColumnPrivilege>) query.executeWithArray(principalName,
+              principalType.toString(), tableName, dbName, partitionName, columnName);
+      pm.retrieveAll(mPrivs);
+      success = commitTransaction();
 
-      mSecurityColList = (List<MPartitionColumnPrivilege>) query
-          .executeWithArray(principalName, principalType.toString(), tableName,
-              dbName, partitionName, columnName);
-      LOG.debug("Done executing query for listPrincipalPartitionColumnGrants");
-      pm.retrieveAll(mSecurityColList);
+      mSecurityColList.addAll(mPrivs);
 
-      success = commitTransaction();
-      LOG
-          .debug("Done retrieving all objects for listPrincipalPartitionColumnGrants");
+      LOG.debug("Done retrieving all objects for listPrincipalPartitionColumnGrants");
     } finally {
       if (!success) {
         rollbackTransaction();
       }
+      if (query != null) {
+        query.closeAll();
+      }
     }
     return mSecurityColList;
   }
 
   @Override
-  public List<HiveObjectPrivilege> listPrincipalPartitionColumnGrantsAll(
-      String principalName, PrincipalType principalType) {
+  public List<HiveObjectPrivilege> listPrincipalPartitionColumnGrantsAll(String principalName,
+      PrincipalType principalType) {
     boolean success = false;
+    Query query = null;
     try {
       openTransaction();
       LOG.debug("Executing listPrincipalPartitionColumnGrantsAll");
       List<MPartitionColumnPrivilege> mSecurityTabPartList;
       if (principalName != null && principalType != null) {
-        Query query = pm.newQuery(MPartitionColumnPrivilege.class,
-            "principalName == t1 && principalType == t2");
+        query =
+            pm.newQuery(MPartitionColumnPrivilege.class,
+                "principalName == t1 && principalType == t2");
         query.declareParameters("java.lang.String t1, java.lang.String t2");
-        mSecurityTabPartList = (List<MPartitionColumnPrivilege>)
-            query.executeWithArray(principalName, principalType.toString());
+        mSecurityTabPartList =
+            (List<MPartitionColumnPrivilege>) query.executeWithArray(principalName,
+                principalType.toString());
       } else {
-        Query query = pm.newQuery(MPartitionColumnPrivilege.class);
+        query = pm.newQuery(MPartitionColumnPrivilege.class);
         mSecurityTabPartList = (List<MPartitionColumnPrivilege>) query.execute();
       }
       LOG.debug("Done executing query for listPrincipalPartitionColumnGrantsAll");
@@ -4958,23 +5091,29 @@ private void dropPartitionGrantsNoTxn(String dbName, String tableName, List<Stri
       if (!success) {
         rollbackTransaction();
       }
+      if (query != null) {
+        query.closeAll();
+      }
     }
   }
 
   @Override
-  public List<HiveObjectPrivilege> listPartitionColumnGrantsAll(
-      String dbName, String tableName, String partitionName, String columnName) {
+  public List<HiveObjectPrivilege> listPartitionColumnGrantsAll(String dbName, String tableName,
+      String partitionName, String columnName) {
     boolean success = false;
+    Query query = null;
     try {
       openTransaction();
       LOG.debug("Executing listPartitionColumnGrantsAll");
-      Query query = pm.newQuery(MPartitionColumnPrivilege.class,
-          "partition.table.tableName == t3 && partition.table.database.name == t4 && " +
-          "partition.partitionName == t5 && columnName == t6");
-      query.declareParameters(
-          "java.lang.String t3, java.lang.String t4, java.lang.String t5, java.lang.String t6");
-      List<MPartitionColumnPrivilege> mSecurityTabPartList = (List<MPartitionColumnPrivilege>)
-          query.executeWithArray(tableName, dbName, partitionName, columnName);
+      query =
+          pm.newQuery(MPartitionColumnPrivilege.class,
+              "partition.table.tableName == t3 && partition.table.database.name == t4 && "
+                  + "partition.partitionName == t5 && columnName == t6");
+      query
+          .declareParameters("java.lang.String t3, java.lang.String t4, java.lang.String t5, java.lang.String t6");
+      List<MPartitionColumnPrivilege> mSecurityTabPartList =
+          (List<MPartitionColumnPrivilege>) query.executeWithArray(tableName, dbName,
+              partitionName, columnName);
       LOG.debug("Done executing query for listPartitionColumnGrantsAll");
       pm.retrieveAll(mSecurityTabPartList);
       List<HiveObjectPrivilege> result = convertPartCols(mSecurityTabPartList);
@@ -4985,6 +5124,9 @@ private void dropPartitionGrantsNoTxn(String dbName, String tableName, List<Stri
       if (!success) {
         rollbackTransaction();
       }
+      if (query != null) {
+        query.closeAll();
+      }
     }
   }
 
@@ -5010,23 +5152,22 @@ private void dropPartitionGrantsNoTxn(String dbName, String tableName, List<Stri
 
   @SuppressWarnings("unchecked")
   private List<MTablePrivilege> listPrincipalAllTableGrants(
-      String principalName, PrincipalType principalType) {
+      String principalName, PrincipalType principalType, QueryWrapper queryWrapper) {
     boolean success = false;
     List<MTablePrivilege> mSecurityTabPartList = null;
     try {
-      openTransaction();
       LOG.debug("Executing listPrincipalAllTableGrants");
-      Query query = pm.newQuery(MTablePrivilege.class,
+
+      openTransaction();
+      Query query = queryWrapper.query = pm.newQuery(MTablePrivilege.class,
           "principalName == t1 && principalType == t2");
       query.declareParameters("java.lang.String t1, java.lang.String t2");
       mSecurityTabPartList = (List<MTablePrivilege>) query.execute(
           principalName, principalType.toString());
-      LOG
-          .debug("Done executing query for listPrincipalAllTableGrants");
       pm.retrieveAll(mSecurityTabPartList);
       success = commitTransaction();
-      LOG
-          .debug("Done retrieving all objects for listPrincipalAllTableGrants");
+
+      LOG.debug("Done retrieving all objects for listPrincipalAllTableGrants");
     } finally {
       if (!success) {
         rollbackTransaction();
@@ -5036,21 +5177,21 @@ private void dropPartitionGrantsNoTxn(String dbName, String tableName, List<Stri
   }
 
   @Override
-  public List<HiveObjectPrivilege> listPrincipalTableGrantsAll(
-      String principalName, PrincipalType principalType) {
+  public List<HiveObjectPrivilege> listPrincipalTableGrantsAll(String principalName,
+      PrincipalType principalType) {
     boolean success = false;
+    Query query = null;
     try {
       openTransaction();
       LOG.debug("Executing listPrincipalAllTableGrants");
       List<MTablePrivilege> mSecurityTabPartList;
       if (principalName != null && principalType != null) {
-        Query query = pm.newQuery(MTablePrivilege.class,
-            "principalName == t1 && principalType == t2");
+        query = pm.newQuery(MTablePrivilege.class, "principalName == t1 && principalType == t2");
         query.declareParameters("java.lang.String t1, java.lang.String t2");
-        mSecurityTabPartList = (List<MTablePrivilege>) query.execute(
-            principalName, principalType.toString());
+        mSecurityTabPartList =
+            (List<MTablePrivilege>) query.execute(principalName, principalType.toString());
       } else {
-        Query query = pm.newQuery(MTablePrivilege.class);
+        query = pm.newQuery(MTablePrivilege.class);
         mSecurityTabPartList = (List<MTablePrivilege>) query.execute();
       }
       LOG.debug("Done executing query for listPrincipalAllTableGrants");
@@ -5063,20 +5204,24 @@ private void dropPartitionGrantsNoTxn(String dbName, String tableName, List<Stri
       if (!success) {
         rollbackTransaction();
       }
+      if (query != null) {
+        query.closeAll();
+      }
     }
   }
 
   @Override
   public List<HiveObjectPrivilege> listTableGrantsAll(String dbName, String tableName) {
     boolean success = false;
+    Query query = null;
     try {
       openTransaction();
       LOG.debug("Executing listTableGrantsAll");
-      Query query = pm.newQuery(MTablePrivilege.class,
-          "table.tableName == t1 && table.database.name == t2");
+      query =
+          pm.newQuery(MTablePrivilege.class, "table.tableName == t1 && table.database.name == t2");
       query.declareParameters("java.lang.String t1, java.lang.String t2");
-      List<MTablePrivilege> mSecurityTabPartList = (List<MTablePrivilege>)
-          query.executeWithArray(tableName, dbName);
+      List<MTablePrivilege> mSecurityTabPartList =
+          (List<MTablePrivilege>) query.executeWithArray(tableName, dbName);
       LOG.debug("Done executing query for listTableGrantsAll");
       pm.retrieveAll(mSecurityTabPartList);
       List<HiveObjectPrivilege> result = convertTable(mSecurityTabPartList);
@@ -5087,6 +5232,9 @@ private void dropPartitionGrantsNoTxn(String dbName, String tableName, List<Stri
       if (!success) {
         rollbackTransaction();
       }
+      if (query != null) {
+        query.closeAll();
+      }
     }
   }
 
@@ -5110,24 +5258,20 @@ private void dropPartitionGrantsNoTxn(String dbName, String tableName, List<Stri
   }
 
   @SuppressWarnings("unchecked")
-  private List<MPartitionPrivilege> listPrincipalAllPartitionGrants(
-      String principalName, PrincipalType principalType) {
+  private List<MPartitionPrivilege> listPrincipalAllPartitionGrants(String principalName,
+      PrincipalType principalType, QueryWrapper queryWrapper) {
     boolean success = false;
     List<MPartitionPrivilege> mSecurityTabPartList = null;
     try {
       openTransaction();
       LOG.debug("Executing listPrincipalAllPartitionGrants");
-      Query query = pm.newQuery(MPartitionPrivilege.class,
-          "principalName == t1 && principalType == t2");
+      Query query = queryWrapper.query = pm.newQuery(MPartitionPrivilege.class, "principalName == t1 && principalType == t2");
       query.declareParameters("java.lang.String t1, java.lang.String t2");
-      mSecurityTabPartList = (List<MPartitionPrivilege>) query.execute(
-          principalName, principalType.toString());
-      LOG
-          .debug("Done executing query for listPrincipalAllPartitionGrants");
+      mSecurityTabPartList =
+          (List<MPartitionPrivilege>) query.execute(principalName, principalType.toString());
       pm.retrieveAll(mSecurityTabPartList);
       success = commitTransaction();
-      LOG
-          .debug("Done retrieving all objects for listPrincipalAllPartitionGrants");
+      LOG.debug("Done retrieving all objects for listPrincipalAllPartitionGrants");
     } finally {
       if (!success) {
         rollbackTransaction();
@@ -5137,21 +5281,22 @@ private void dropPartitionGrantsNoTxn(String dbName, String tableName, List<Stri
   }
 
   @Override
-  public List<HiveObjectPrivilege> listPrincipalPartitionGrantsAll(
-      String principalName, PrincipalType principalType) {
+  public List<HiveObjectPrivilege> listPrincipalPartitionGrantsAll(String principalName,
+      PrincipalType principalType) {
     boolean success = false;
+    Query query = null;
     try {
       openTransaction();
       LOG.debug("Executing listPrincipalPartitionGrantsAll");
       List<MPartitionPrivilege> mSecurityTabPartList;
       if (principalName != null && principalType != null) {
-        Query query = pm.newQuery(MPartitionPrivilege.class,
-            "principalName == t1 && principalType == t2");
+        query =
+            pm.newQuery(MPartitionPrivilege.class, "principalName == t1 && principalType == t2");
         query.declareParameters("java.lang.String t1, java.lang.String t2");
-        mSecurityTabPartList = (List<MPartitionPrivilege>)
-            query.execute(principalName, principalType.toString());
+        mSecurityTabPartList =
+            (List<MPartitionPrivilege>) query.execute(principalName, principalType.toString());
       } else {
-        Query query = pm.newQuery(MPartitionPrivilege.class);
+        query = pm.newQuery(MPartitionPrivilege.class);
         mSecurityTabPartList = (List<MPartitionPrivilege>) query.execute();
       }
       LOG.debug("Done executing query for listPrincipalPartitionGrantsAll");
@@ -5164,22 +5309,27 @@ private void dropPartitionGrantsNoTxn(String dbName, String tableName, List<Stri
       if (!success) {
         rollbackTransaction();
       }
+      if (query != null) {
+        query.closeAll();
+      }
     }
   }
 
   @Override
-  public List<HiveObjectPrivilege> listPartitionGrantsAll(
-      String dbName, String tableName, String partitionName) {
+  public List<HiveObjectPrivilege> listPartitionGrantsAll(String dbName, String tableName,
+      String partitionName) {
     boolean success = false;
+    Query query = null;
     try {
       openTransaction();
       LOG.debug("Executing listPrincipalPartitionGrantsAll");
-      Query query = pm.newQuery(MPartitionPrivilege.class,
-          "partition.table.tableName == t3 && partition.table.database.name == t4 && " +
-          "partition.partitionName == t5");
+      query =
+          pm.newQuery(MPartitionPrivilege.class,
+              "partition.table.tableName == t3 && partition.table.database.name == t4 && "
+                  + "partition.partitionName == t5");
       query.declareParameters("java.lang.String t3, java.lang.String t4, java.lang.String t5");
-      List<MPartitionPrivilege> mSecurityTabPartList = (List<MPartitionPrivilege>)
-          query.executeWithArray(tableName, dbName, partitionName);
+      List<MPartitionPrivilege> mSecurityTabPartList =
+          (List<MPartitionPrivilege>) query.executeWithArray(tableName, dbName, partitionName);
       LOG.debug("Done executing query for listPrincipalPartitionGrantsAll");
       pm.retrieveAll(mSecurityTabPartList);
       List<HiveObjectPrivilege> result = convertPartition(mSecurityTabPartList);
@@ -5190,6 +5340,9 @@ private void dropPartitionGrantsNoTxn(String dbName, String tableName, List<Stri
       if (!success) {
         rollbackTransaction();
       }
+      if (query != null) {
+        query.closeAll();
+      }
     }
   }
 
@@ -5214,22 +5367,23 @@ private void dropPartitionGrantsNoTxn(String dbName, String tableName, List<Stri
   }
 
   @SuppressWarnings("unchecked")
-  private List<MTableColumnPrivilege> listPrincipalAllTableColumnGrants(
-      String principalName, PrincipalType principalType) {
+  private List<MTableColumnPrivilege> listPrincipalAllTableColumnGrants(String principalName,
+      PrincipalType principalType, QueryWrapper queryWrapper) {
     boolean success = false;
+
     List<MTableColumnPrivilege> mSecurityColumnList = null;
     try {
-      openTransaction();
       LOG.debug("Executing listPrincipalAllTableColumnGrants");
-      Query query = pm.newQuery(MTableColumnPrivilege.class,
-          "principalName == t1 && principalType == t2");
-      query
-          .declareParameters("java.lang.String t1, java.lang.String t2");
-      mSecurityColumnList = (List<MTableColumnPrivilege>) query.execute(
-          principalName, principalType.toString());
-      LOG.debug("Done executing query for listPrincipalAllTableColumnGrants");
+
+      openTransaction();
+      Query query = queryWrapper.query =
+          pm.newQuery(MTableColumnPrivilege.class, "principalName == t1 && principalType == t2");
+      query.declareParameters("java.lang.String t1, java.lang.String t2");
+      mSecurityColumnList =
+          (List<MTableColumnPrivilege>) query.execute(principalName, principalType.toString());
       pm.retrieveAll(mSecurityColumnList);
       success = commitTransaction();
+
       LOG.debug("Done retrieving all objects for listPrincipalAllTableColumnGrants");
     } finally {
       if (!success) {
@@ -5240,22 +5394,23 @@ private void dropPartitionGrantsNoTxn(String dbName, String tableName, List<Stri
   }
 
   @Override
-  public List<HiveObjectPrivilege> listPrincipalTableColumnGrantsAll(
-      String principalName, PrincipalType principalType) {
+  public List<HiveObjectPrivilege> listPrincipalTableColumnGrantsAll(String principalName,
+      PrincipalType principalType) {
     boolean success = false;
+    Query query = null;
     try {
       openTransaction();
       LOG.debug("Executing listPrincipalTableColumnGrantsAll");
 
       List<MTableColumnPrivilege> mSecurityTabPartList;
       if (principalName != null && principalType != null) {
-        Query query = pm.newQuery(MTableColumnPrivilege.class,
-            "principalName == t1 && principalType == t2");
+        query =
+            pm.newQuery(MTableColumnPrivilege.class, "principalName == t1 && principalType == t2");
         query.declareParameters("java.lang.String t1, java.lang.String t2");
-        mSecurityTabPartList = (List<MTableColumnPrivilege>)
-            query.execute(principalName, principalType.toString());
+        mSecurityTabPartList =
+            (List<MTableColumnPrivilege>) query.execute(principalName, principalType.toString());
       } else {
-        Query query = pm.newQuery(MTableColumnPrivilege.class);
+        query = pm.newQuery(MTableColumnPrivilege.class);
         mSecurityTabPartList = (List<MTableColumnPrivilege>) query.execute();
       }
       LOG.debug("Done executing query for listPrincipalTableColumnGrantsAll");
@@ -5268,21 +5423,26 @@ private void dropPartitionGrantsNoTxn(String dbName, String tableName, List<Stri
       if (!success) {
         rollbackTransaction();
       }
+      if (query != null) {
+        query.closeAll();
+      }
     }
   }
 
   @Override
-  public List<HiveObjectPrivilege> listTableColumnGrantsAll(
-      String dbName, String tableName, String columnName) {
+  public List<HiveObjectPrivilege> listTableColumnGrantsAll(String dbName, String tableName,
+      String columnName) {
     boolean success = false;
+    Query query = null;
     try {
       openTransaction();
       LOG.debug("Executing listPrincipalTableColumnGrantsAll");
-      Query query = pm.newQuery(MTableColumnPrivilege.class,
-          "table.tableName == t3 && table.database.name == t4 &&  columnName == t5");
+      query =
+          pm.newQuery(MTableColumnPrivilege.class,
+              "table.tableName == t3 && table.database.name == t4 &&  columnName == t5");
       query.declareParameters("java.lang.String t3, java.lang.String t4, java.lang.String t5");
-      List<MTableColumnPrivilege> mSecurityTabPartList = (List<MTableColumnPrivilege>)
-          query.executeWithArray(tableName, dbName, columnName);
+      List<MTableColumnPrivilege> mSecurityTabPartList =
+          (List<MTableColumnPrivilege>) query.executeWithArray(tableName, dbName, columnName);
       LOG.debug("Done executing query for listPrincipalTableColumnGrantsAll");
       pm.retrieveAll(mSecurityTabPartList);
       List<HiveObjectPrivilege> result = convertTableCols(mSecurityTabPartList);
@@ -5293,6 +5453,9 @@ private void dropPartitionGrantsNoTxn(String dbName, String tableName, List<Stri
       if (!success) {
         rollbackTransaction();
       }
+      if (query != null) {
+        query.closeAll();
+      }
     }
   }
 
@@ -5317,21 +5480,21 @@ private void dropPartitionGrantsNoTxn(String dbName, String tableName, List<Stri
 
   @SuppressWarnings("unchecked")
   private List<MPartitionColumnPrivilege> listPrincipalAllPartitionColumnGrants(
-      String principalName, PrincipalType principalType) {
+      String principalName, PrincipalType principalType, QueryWrapper queryWrapper) {
     boolean success = false;
     List<MPartitionColumnPrivilege> mSecurityColumnList = null;
     try {
-      openTransaction();
       LOG.debug("Executing listPrincipalAllTableColumnGrants");
-      Query query = pm.newQuery(MPartitionColumnPrivilege.class,
-          "principalName == t1 && principalType == t2");
-      query
-          .declareParameters("java.lang.String t1, java.lang.String t2");
-      mSecurityColumnList = (List<MPartitionColumnPrivilege>) query.execute(
-          principalName, principalType.toString());
-      LOG.debug("Done executing query for listPrincipalAllTableColumnGrants");
+
+      openTransaction();
+      Query query = queryWrapper.query =
+          pm.newQuery(MPartitionColumnPrivilege.class, "principalName == t1 && principalType == t2");
+      query.declareParameters("java.lang.String t1, java.lang.String t2");
+      mSecurityColumnList =
+          (List<MPartitionColumnPrivilege>) query.execute(principalName, principalType.toString());
       pm.retrieveAll(mSecurityColumnList);
       success = commitTransaction();
+
       LOG.debug("Done retrieving all objects for listPrincipalAllTableColumnGrants");
     } finally {
       if (!success) {
@@ -5345,29 +5508,37 @@ private void dropPartitionGrantsNoTxn(String dbName, String tableName, List<Stri
   public boolean isPartitionMarkedForEvent(String dbName, String tblName,
       Map<String, String> partName, PartitionEventType evtType) throws UnknownTableException,
       MetaException, InvalidPartitionException, UnknownPartitionException {
-
-    Collection<MPartitionEvent> partEvents;
     boolean success = false;
-    LOG.debug("Begin Executing isPartitionMarkedForEvent");
-    try{
-    openTransaction();
-    Query query = pm.newQuery(MPartitionEvent.class, "dbName == t1 && tblName == t2 && partName == t3 && eventType == t4");
-    query.declareParameters("java.lang.String t1, java.lang.String t2, java.lang.String t3, int t4");
-    Table tbl = getTable(dbName, tblName); // Make sure dbName and tblName are valid.
-    if(null == tbl) {
-      throw new UnknownTableException("Table: "+ tblName + " is not found.");
-    }
-    partEvents = (Collection<MPartitionEvent>) query.executeWithArray(dbName, tblName, getPartitionStr(tbl, partName), evtType.getValue());
-    pm.retrieveAll(partEvents);
-    success = commitTransaction();
-    LOG.debug("Done executing isPartitionMarkedForEvent");
-    } finally{
+    Query query = null;
+
+    try {
+      LOG.debug("Begin Executing isPartitionMarkedForEvent");
+
+      openTransaction();
+      query = pm.newQuery(MPartitionEvent.class,
+              "dbName == t1 && tblName == t2 && partName == t3 && eventType == t4");
+      query
+          .declareParameters("java.lang.String t1, java.lang.String t2, java.lang.String t3, int t4");
+      Table tbl = getTable(dbName, tblName); // Make sure dbName and tblName are valid.
+      if (null == tbl) {
+        throw new UnknownTableException("Table: " + tblName + " is not found.");
+      }
+      Collection<MPartitionEvent> partEvents =
+          (Collection<MPartitionEvent>) query.executeWithArray(dbName, tblName,
+              getPartitionStr(tbl, partName), evtType.getValue());
+      pm.retrieveAll(partEvents);
+      success = commitTransaction();
+
+      LOG.debug("Done executing isPartitionMarkedForEvent");
+      return (partEvents != null && !partEvents.isEmpty()) ? true : false;
+    } finally {
       if (!success) {
         rollbackTransaction();
       }
+      if (query != null) {
+        query.closeAll();
+      }
     }
-    return (partEvents != null  && !partEvents.isEmpty()) ? true : false;
-
   }
 
   @Override
@@ -5417,15 +5588,16 @@ private String getPartitionStr(Table tbl, Map<String,String> partName) throws In
    * is used by HiveMetaTool. This API **shouldn't** be exposed via Thrift.
    *
    */
-  public Collection<?> executeJDOQLSelect(String query) {
+  public Collection<?> executeJDOQLSelect(String queryStr, QueryWrapper queryWrapper) {
     boolean committed = false;
     Collection<?> result = null;
 
     try {
       openTransaction();
-      Query q = pm.newQuery(query);
-      result = (Collection<?>) q.execute();
+      Query query = queryWrapper.query = pm.newQuery(queryStr);
+      result = ((Collection<?>) query.execute());
       committed = commitTransaction();
+
       if (committed) {
         return result;
       } else {
@@ -5445,14 +5617,14 @@ private String getPartitionStr(Table tbl, Map<String,String> partName) throws In
   * is used by HiveMetaTool. This API **shouldn't** be exposed via Thrift.
   *
   */
-  public long executeJDOQLUpdate(String query) {
+  public long executeJDOQLUpdate(String queryStr) {
     boolean committed = false;
     long numUpdated = 0;
-
+    Query query = null;
     try {
       openTransaction();
-      Query q = pm.newQuery(query);
-      numUpdated = (Long) q.execute();
+      query = pm.newQuery(queryStr);
+      numUpdated = (Long) query.execute();
       committed = commitTransaction();
       if (committed) {
         return numUpdated;
@@ -5463,6 +5635,9 @@ public long executeJDOQLUpdate(String query) {
       if (!committed) {
         rollbackTransaction();
       }
+      if (query != null) {
+        query.closeAll();
+      }
     }
   }
 
@@ -5475,15 +5650,14 @@ public long executeJDOQLUpdate(String query) {
   */
   public Set<String> listFSRoots() {
     boolean committed = false;
+    Query query = null;
     Set<String> fsRoots = new HashSet<String>();
-
     try {
       openTransaction();
-      Query query = pm.newQuery(MDatabase.class);
+      query = pm.newQuery(MDatabase.class);
       List<MDatabase> mDBs = (List<MDatabase>) query.execute();
       pm.retrieveAll(mDBs);
-
-      for (MDatabase mDB:mDBs) {
+      for (MDatabase mDB : mDBs) {
         fsRoots.add(mDB.getLocationUri());
       }
       committed = commitTransaction();
@@ -5496,6 +5670,9 @@ public long executeJDOQLUpdate(String query) {
       if (!committed) {
         rollbackTransaction();
       }
+      if (query != null) {
+        query.closeAll();
+      }
     }
   }
 
@@ -5570,17 +5747,17 @@ public void setUpdateLocations(Map<String, String> updateLocations) {
   */
   public UpdateMDatabaseURIRetVal updateMDatabaseURI(URI oldLoc, URI newLoc, boolean dryRun) {
     boolean committed = false;
+    Query query = null;
     Map<String, String> updateLocations = new HashMap<String, String>();
     List<String> badRecords = new ArrayList<String>();
     UpdateMDatabaseURIRetVal retVal = null;
-
     try {
       openTransaction();
-      Query query = pm.newQuery(MDatabase.class);
+      query = pm.newQuery(MDatabase.class);
       List<MDatabase> mDBs = (List<MDatabase>) query.execute();
       pm.retrieveAll(mDBs);
 
-      for(MDatabase mDB:mDBs) {
+      for (MDatabase mDB : mDBs) {
         URI locationURI = null;
         String location = mDB.getLocationUri();
         try {
@@ -5611,6 +5788,9 @@ public UpdateMDatabaseURIRetVal updateMDatabaseURI(URI oldLoc, URI newLoc, boole
       if (!committed) {
         rollbackTransaction();
       }
+      if (query != null) {
+        query.closeAll();
+      }
     }
   }
 
@@ -5677,16 +5857,16 @@ private void updatePropURIHelper(URI oldLoc, URI newLoc, String tblPropKey, bool
    * is used by HiveMetaTool. This API **shouldn't** be exposed via Thrift.
    *
    */
-  public UpdatePropURIRetVal updateTblPropURI(URI oldLoc, URI newLoc, String tblPropKey, boolean
-      isDryRun) {
+  public UpdatePropURIRetVal updateTblPropURI(URI oldLoc, URI newLoc, String tblPropKey,
+      boolean isDryRun) {
     boolean committed = false;
+    Query query = null;
     Map<String, String> updateLocations = new HashMap<>();
     List<String> badRecords = new ArrayList<>();
     UpdatePropURIRetVal retVal = null;
-
     try {
       openTransaction();
-      Query query = pm.newQuery(MTable.class);
+      query = pm.newQuery(MTable.class);
       List<MTable> mTbls = (List<MTable>) query.execute();
       pm.retrieveAll(mTbls);
 
@@ -5703,6 +5883,9 @@ public UpdatePropURIRetVal updateTblPropURI(URI oldLoc, URI newLoc, String tblPr
       if (!committed) {
         rollbackTransaction();
       }
+      if (query != null) {
+        query.closeAll();
+      }
     }
   }
 
@@ -5714,20 +5897,19 @@ public UpdatePropURIRetVal updateTblPropURI(URI oldLoc, URI newLoc, String tblPr
   *
   */
   @Deprecated
-  public UpdatePropURIRetVal updateMStorageDescriptorTblPropURI(URI oldLoc,
-      URI newLoc, String tblPropKey, boolean isDryRun) {
+  public UpdatePropURIRetVal updateMStorageDescriptorTblPropURI(URI oldLoc, URI newLoc,
+      String tblPropKey, boolean isDryRun) {
     boolean committed = false;
+    Query query = null;
     Map<String, String> updateLocations = new HashMap<String, String>();
     List<String> badRecords = new ArrayList<String>();
     UpdatePropURIRetVal retVal = null;
-
     try {
       openTransaction();
-      Query query = pm.newQuery(MStorageDescriptor.class);
+      query = pm.newQuery(MStorageDescriptor.class);
       List<MStorageDescriptor> mSDSs = (List<MStorageDescriptor>) query.execute();
       pm.retrieveAll(mSDSs);
-
-      for(MStorageDescriptor mSDS:mSDSs) {
+      for (MStorageDescriptor mSDS : mSDSs) {
         updatePropURIHelper(oldLoc, newLoc, tblPropKey, isDryRun, badRecords, updateLocations,
             mSDS.getParameters());
       }
@@ -5736,11 +5918,14 @@ public UpdatePropURIRetVal updateMStorageDescriptorTblPropURI(URI oldLoc,
         retVal = new UpdatePropURIRetVal(badRecords, updateLocations);
       }
       return retVal;
-     } finally {
-        if (!committed) {
-          rollbackTransaction();
-        }
-     }
+    } finally {
+      if (!committed) {
+        rollbackTransaction();
+      }
+      if (query != null) {
+        query.closeAll();
+      }
+    }
   }
 
   public class UpdateMStorageDescriptorTblURIRetVal {
@@ -5777,20 +5962,19 @@ public void setUpdateLocations(Map<String, String> updateLocations) {
   * is used by HiveMetaTool. This API **shouldn't** be exposed via Thrift.
   *
   */
-  public UpdateMStorageDescriptorTblURIRetVal updateMStorageDescriptorTblURI(URI oldLoc, URI newLoc,
-    boolean isDryRun) {
+  public UpdateMStorageDescriptorTblURIRetVal updateMStorageDescriptorTblURI(URI oldLoc,
+      URI newLoc, boolean isDryRun) {
     boolean committed = false;
+    Query query = null;
     Map<String, String> updateLocations = new HashMap<String, String>();
     List<String> badRecords = new ArrayList<String>();
     UpdateMStorageDescriptorTblURIRetVal retVal = null;
-
     try {
       openTransaction();
-      Query query = pm.newQuery(MStorageDescriptor.class);
+      query = pm.newQuery(MStorageDescriptor.class);
       List<MStorageDescriptor> mSDSs = (List<MStorageDescriptor>) query.execute();
       pm.retrieveAll(mSDSs);
-
-      for(MStorageDescriptor mSDS:mSDSs) {
+      for (MStorageDescriptor mSDS : mSDSs) {
         URI locationURI = null;
         String location = mSDS.getLocation();
         try {
@@ -5818,10 +6002,13 @@ public UpdateMStorageDescriptorTblURIRetVal updateMStorageDescriptorTblURI(URI o
       }
       return retVal;
     } finally {
-        if (!committed) {
-          rollbackTransaction();
-        }
-     }
+      if (!committed) {
+        rollbackTransaction();
+      }
+      if (query != null) {
+        query.closeAll();
+      }
+    }
   }
 
   public class UpdateSerdeURIRetVal {
@@ -5858,19 +6045,18 @@ public void setUpdateLocations(Map<String, String> updateLocations) {
   *
   */
   public UpdateSerdeURIRetVal updateSerdeURI(URI oldLoc, URI newLoc, String serdeProp,
-    boolean isDryRun) {
+      boolean isDryRun) {
     boolean committed = false;
+    Query query = null;
     Map<String, String> updateLocations = new HashMap<String, String>();
     List<String> badRecords = new ArrayList<String>();
     UpdateSerdeURIRetVal retVal = null;
-
     try {
       openTransaction();
-      Query query = pm.newQuery(MSerDeInfo.class);
+      query = pm.newQuery(MSerDeInfo.class);
       List<MSerDeInfo> mSerdes = (List<MSerDeInfo>) query.execute();
       pm.retrieveAll(mSerdes);
-
-      for(MSerDeInfo mSerde:mSerdes) {
+      for (MSerDeInfo mSerde : mSerdes) {
         if (mSerde.getParameters().containsKey(serdeProp)) {
           String schemaLoc = mSerde.getParameters().get(serdeProp);
           URI schemaLocURI = null;
@@ -5903,6 +6089,9 @@ public UpdateSerdeURIRetVal updateSerdeURI(URI oldLoc, URI newLoc, String serdeP
       if (!committed) {
         rollbackTransaction();
       }
+      if (query != null) {
+        query.closeAll();
+      }
     }
   }
 
@@ -5911,19 +6100,24 @@ private void writeMTableColumnStatistics(Table table, MTableColumnStatistics mSt
     String dbName = mStatsObj.getDbName();
     String tableName = mStatsObj.getTableName();
     String colName = mStatsObj.getColName();
+    QueryWrapper queryWrapper = new QueryWrapper();
 
-    LOG.info("Updating table level column statistics for db=" + dbName + " tableName=" + tableName
-      + " colName=" + colName);
-    validateTableCols(table, Lists.newArrayList(colName));
+    try {
+      LOG.info("Updating table level column statistics for db=" + dbName + " tableName=" + tableName
+        + " colName=" + colName);
+      validateTableCols(table, Lists.newArrayList(colName));
 
-    List<MTableColumnStatistics> oldStats =
-        getMTableColumnStatistics(table, Lists.newArrayList(colName));
+      List<MTableColumnStatistics> oldStats =
+          getMTableColumnStatistics(table, Lists.newArrayList(colName), queryWrapper);
 
-    if (!oldStats.isEmpty()) {
-      assert oldStats.size() == 1;
-      StatObjectConverter.setFieldsIntoOldStats(mStatsObj, oldStats.get(0));
-    } else {
-      pm.makePersistent(mStatsObj);
+      if (!oldStats.isEmpty()) {
+        assert oldStats.size() == 1;
+        StatObjectConverter.setFieldsIntoOldStats(mStatsObj, oldStats.get(0));
+      } else {
+        pm.makePersistent(mStatsObj);
+      }
+    } finally {
+      queryWrapper.close();
     }
   }
 
@@ -5953,16 +6147,21 @@ private void writeMPartitionColumnStatistics(Table table, Partition partition,
         " for which stats gathering is requested doesn't exist.");
     }
 
-    List<MPartitionColumnStatistics> oldStats = getMPartitionColumnStatistics(
-        table, Lists.newArrayList(partName), Lists.newArrayList(colName));
-    if (!oldStats.isEmpty()) {
-      assert oldStats.size() == 1;
-      StatObjectConverter.setFieldsIntoOldStats(mStatsObj, oldStats.get(0));
+    QueryWrapper queryWrapper = new QueryWrapper();
+    try {
+      List<MPartitionColumnStatistics> oldStats = getMPartitionColumnStatistics(
+          table, Lists.newArrayList(partName), Lists.newArrayList(colName), queryWrapper);
+      if (!oldStats.isEmpty()) {
+        assert oldStats.size() == 1;
+        StatObjectConverter.setFieldsIntoOldStats(mStatsObj, oldStats.get(0));
     } else {
       pm.makePersistent(mStatsObj);
     }
+    } finally {
+      queryWrapper.close();
+    }
   }
-  
+
   @Override
   public boolean updateTableColumnStatistics(ColumnStatistics colStats)
     throws NoSuchObjectException, MetaException, InvalidObjectException, InvalidInputException {
@@ -6023,15 +6222,16 @@ public boolean updatePartitionColumnStatistics(ColumnStatistics colStats, List<S
     }
   }
 
-  private List<MTableColumnStatistics> getMTableColumnStatistics(
-      Table table, List<String> colNames) throws MetaException {
+  private List<MTableColumnStatistics> getMTableColumnStatistics(Table table, List<String> colNames, QueryWrapper queryWrapper)
+      throws MetaException {
     boolean committed = false;
-    openTransaction();
+
     try {
+      openTransaction();
+
       List<MTableColumnStatistics> result = null;
       validateTableCols(table, colNames);
-
-      Query query = pm.newQuery(MTableColumnStatistics.class);
+      Query query = queryWrapper.query = pm.newQuery(MTableColumnStatistics.class);
       String filter = "tableName == t1 && dbName == t2 && (";
       String paramStr = "java.lang.String t1, java.lang.String t2";
       Object[] params = new Object[colNames.size() + 2];
@@ -6048,15 +6248,15 @@ public boolean updatePartitionColumnStatistics(ColumnStatistics colStats, List<S
       result = (List<MTableColumnStatistics>) query.executeWithArray(params);
       pm.retrieveAll(result);
       if (result.size() > colNames.size()) {
-        throw new MetaException(
-            "Unexpected " + result.size() + " statistics for " + colNames.size() + " columns");
+        throw new MetaException("Unexpected " + result.size() + " statistics for "
+            + colNames.size() + " columns");
       }
       committed = commitTransaction();
       return result;
     } catch (Exception ex) {
       LOG.error("Error retrieving statistics via jdo", ex);
       if (ex instanceof MetaException) {
-        throw (MetaException)ex;
+        throw (MetaException) ex;
       }
       throw new MetaException(ex.getMessage());
     } finally {
@@ -6100,8 +6300,11 @@ protected ColumnStatistics getSqlResult(GetHelper<ColumnStatistics> ctx) throws
       }
       @Override
       protected ColumnStatistics getJdoResult(
-          GetHelper<ColumnStatistics> ctx) throws MetaException, NoSuchObjectException {
-        List<MTableColumnStatistics> mStats = getMTableColumnStatistics(getTable(), colNames);
+          GetHelper<ColumnStatistics> ctx) throws MetaException {
+        QueryWrapper queryWrapper = new QueryWrapper();
+
+        try {
+        List<MTableColumnStatistics> mStats = getMTableColumnStatistics(getTable(), colNames, queryWrapper);
         if (mStats.isEmpty()) return null;
         // LastAnalyzed is stored per column, but thrift object has it per multiple columns.
         // Luckily, nobody actually uses it, so we will set to lowest value of all columns for now.
@@ -6114,6 +6317,9 @@ protected ColumnStatistics getJdoResult(
           statObjs.add(StatObjectConverter.getTableColumnStatisticsObj(mStat));
         }
         return new ColumnStatistics(desc, statObjs);
+        } finally {
+          queryWrapper.close();
+        }
       }
     }.run(true);
   }
@@ -6137,31 +6343,36 @@ protected ColumnStatistics getJdoResult(
       @Override
       protected List<ColumnStatistics> getJdoResult(
           GetHelper<List<ColumnStatistics>> ctx) throws MetaException, NoSuchObjectException {
-        List<MPartitionColumnStatistics> mStats =
-            getMPartitionColumnStatistics(getTable(), partNames, colNames);
-        List<ColumnStatistics> result = new ArrayList<ColumnStatistics>(
-            Math.min(mStats.size(), partNames.size()));
-        String lastPartName = null;
-        List<ColumnStatisticsObj> curList = null;
-        ColumnStatisticsDesc csd = null;
-        for (int i = 0; i <= mStats.size(); ++i) {
-          boolean isLast = i == mStats.size();
-          MPartitionColumnStatistics mStatsObj = isLast ? null : mStats.get(i);
-          String partName = isLast ? null : (String)mStatsObj.getPartitionName();
-          if (isLast || !partName.equals(lastPartName)) {
-            if (i != 0) {
-              result.add(new ColumnStatistics(csd, curList));
-            }
-            if (isLast) {
-              continue;
+        QueryWrapper queryWrapper = new QueryWrapper();
+        try {
+          List<MPartitionColumnStatistics> mStats =
+              getMPartitionColumnStatistics(getTable(), partNames, colNames, queryWrapper);
+          List<ColumnStatistics> result = new ArrayList<ColumnStatistics>(
+              Math.min(mStats.size(), partNames.size()));
+          String lastPartName = null;
+          List<ColumnStatisticsObj> curList = null;
+          ColumnStatisticsDesc csd = null;
+          for (int i = 0; i <= mStats.size(); ++i) {
+            boolean isLast = i == mStats.size();
+            MPartitionColumnStatistics mStatsObj = isLast ? null : mStats.get(i);
+            String partName = isLast ? null : (String)mStatsObj.getPartitionName();
+            if (isLast || !partName.equals(lastPartName)) {
+              if (i != 0) {
+                result.add(new ColumnStatistics(csd, curList));
+              }
+              if (isLast) {
+                continue;
+              }
+              csd = StatObjectConverter.getPartitionColumnStatisticsDesc(mStatsObj);
+              curList = new ArrayList<ColumnStatisticsObj>(colNames.size());
             }
-            csd = StatObjectConverter.getPartitionColumnStatisticsDesc(mStatsObj);
-            curList = new ArrayList<ColumnStatisticsObj>(colNames.size());
+            curList.add(StatObjectConverter.getPartitionColumnStatisticsObj(mStatsObj));
+            lastPartName = partName;
           }
-          curList.add(StatObjectConverter.getPartitionColumnStatisticsObj(mStatsObj));
-          lastPartName = partName;
+          return result;
+        } finally {
+          queryWrapper.close();
         }
-        return result;
       }
     }.run(true);
   }
@@ -6192,17 +6403,16 @@ protected String describeResult() {
     }.run(true);
   }
 
-  private List<MPartitionColumnStatistics> getMPartitionColumnStatistics(
-      Table table, List<String> partNames, List<String> colNames)
-          throws NoSuchObjectException, MetaException {
+  private List<MPartitionColumnStatistics> getMPartitionColumnStatistics(Table table,
+      List<String> partNames, List<String> colNames,
+      QueryWrapper queryWrapper) throws NoSuchObjectException, MetaException {
     boolean committed = false;
-    MPartitionColumnStatistics mStatsObj = null;
+
     try {
       openTransaction();
       // We are not going to verify SD for each partition. Just verify for the table.
       validateTableCols(table, colNames);
-      boolean foundCol = false;
-      Query query = pm.newQuery(MPartitionColumnStatistics.class);
+      Query query = queryWrapper.query = pm.newQuery(MPartitionColumnStatistics.class);
       String paramStr = "java.lang.String t1, java.lang.String t2";
       String filter = "tableName == t1 && dbName == t2 && (";
       Object[] params = new Object[colNames.size() + partNames.size() + 2];
@@ -6235,7 +6445,7 @@ protected String describeResult() {
     } catch (Exception ex) {
       LOG.error("Error retrieving statistics via jdo", ex);
       if (ex instanceof MetaException) {
-        throw (MetaException)ex;
+        throw (MetaException) ex;
       }
       throw new MetaException(ex.getMessage());
     } finally {
@@ -6255,127 +6465,112 @@ private void dropPartitionColumnStatisticsNoTxn(
   }
 
   @Override
-  public boolean deletePartitionColumnStatistics(String dbName, String tableName,
-    String partName, List<String> partVals, String colName)
-    throws NoSuchObjectException, MetaException, InvalidObjectException, InvalidInputException {
+  public boolean deletePartitionColumnStatistics(String dbName, String tableName, String partName,
+      List<String> partVals, String colName) throws NoSuchObjectException, MetaException,
+      InvalidObjectException, InvalidInputException {
     boolean ret = false;
-
+    Query query = null;
     if (dbName == null) {
       dbName = MetaStoreUtils.DEFAULT_DATABASE_NAME;
     }
-
     if (tableName == null) {
       throw new InvalidInputException("Table name is null.");
     }
-
     try {
       openTransaction();
       MTable mTable = getMTable(dbName, tableName);
       MPartitionColumnStatistics mStatsObj;
       List<MPartitionColumnStatistics> mStatsObjColl;
-
       if (mTable == null) {
-        throw new
-          NoSuchObjectException("Table " + tableName +
-          "  for which stats deletion is requested doesn't exist");
+        throw new NoSuchObjectException("Table " + tableName
+            + "  for which stats deletion is requested doesn't exist");
       }
-
-      MPartition mPartition =
-          getMPartition(dbName, tableName, partVals);
-
+      MPartition mPartition = getMPartition(dbName, tableName, partVals);
       if (mPartition == null) {
-        throw new
-          NoSuchObjectException("Partition " + partName +
-          " for which stats deletion is requested doesn't exist");
+        throw new NoSuchObjectException("Partition " + partName
+            + " for which stats deletion is requested doesn't exist");
       }
-
-      Query query = pm.newQuery(MPartitionColumnStatistics.class);
+      query = pm.newQuery(MPartitionColumnStatistics.class);
       String filter;
       String parameters;
-
       if (colName != null) {
-        filter = "partition.partitionName == t1 && dbName == t2 && tableName == t3 && " +
-                    "colName == t4";
-        parameters = "java.lang.String t1, java.lang.String t2, " +
-                        "java.lang.String t3, java.lang.String t4";
+        filter =
+            "partition.partitionName == t1 && dbName == t2 && tableName == t3 && "
+                + "colName == t4";
+        parameters =
+            "java.lang.String t1, java.lang.String t2, "
+                + "java.lang.String t3, java.lang.String t4";
       } else {
         filter = "partition.partitionName == t1 && dbName == t2 && tableName == t3";
         parameters = "java.lang.String t1, java.lang.String t2, java.lang.String t3";
       }
-
       query.setFilter(filter);
-      query
-        .declareParameters(parameters);
-
+      query.declareParameters(parameters);
       if (colName != null) {
         query.setUnique(true);
-        mStatsObj = (MPartitionColumnStatistics)query.executeWithArray(partName.trim(),
-            HiveStringUtils.normalizeIdentifier(dbName),
-            HiveStringUtils.normalizeIdentifier(tableName),
-            HiveStringUtils.normalizeIdentifier(colName));
+        mStatsObj =
+            (MPartitionColumnStatistics) query.executeWithArray(partName.trim(),
+                HiveStringUtils.normalizeIdentifier(dbName),
+                HiveStringUtils.normalizeIdentifier(tableName),
+                HiveStringUtils.normalizeIdentifier(colName));
         pm.retrieve(mStatsObj);
-
         if (mStatsObj != null) {
           pm.deletePersistent(mStatsObj);
         } else {
-          throw new NoSuchObjectException("Column stats doesn't exist for db=" +dbName + " table="
+          throw new NoSuchObjectException("Column stats doesn't exist for db=" + dbName + " table="
               + tableName + " partition=" + partName + " col=" + colName);
         }
       } else {
-        mStatsObjColl= (List<MPartitionColumnStatistics>)query.execute(partName.trim(),
-            HiveStringUtils.normalizeIdentifier(dbName),
-            HiveStringUtils.normalizeIdentifier(tableName));
+        mStatsObjColl =
+            (List<MPartitionColumnStatistics>) query.execute(partName.trim(),
+                HiveStringUtils.normalizeIdentifier(dbName),
+                HiveStringUtils.normalizeIdentifier(tableName));
         pm.retrieveAll(mStatsObjColl);
-
         if (mStatsObjColl != null) {
           pm.deletePersistentAll(mStatsObjColl);
         } else {
-          throw new NoSuchObjectException("Column stats doesn't exist for db=" + dbName +
-            " table=" + tableName + " partition" + partName);
+          throw new NoSuchObjectException("Column stats doesn't exist for db=" + dbName + " table="
+              + tableName + " partition" + partName);
         }
       }
       ret = commitTransaction();
-    } catch(NoSuchObjectException e) {
-       rollbackTransaction();
-       throw e;
+    } catch (NoSuchObjectException e) {
+      rollbackTransaction();
+      throw e;
     } finally {
       if (!ret) {
         rollbackTransaction();
       }
+      if (query != null) {
+        query.closeAll();
+      }
     }
     return ret;
   }
 
   @Override
   public boolean deleteTableColumnStatistics(String dbName, String tableName, String colName)
-    throws NoSuchObjectException, MetaException, InvalidObjectException, InvalidInputException
-  {
+      throws NoSuchObjectException, MetaException, InvalidObjectException, InvalidInputException {
     boolean ret = false;
-
+    Query query = null;
     if (dbName == null) {
       dbName = MetaStoreUtils.DEFAULT_DATABASE_NAME;
     }
-
     if (tableName == null) {
       throw new InvalidInputException("Table name is null.");
     }
-
     try {
       openTransaction();
       MTable mTable = getMTable(dbName, tableName);
       MTableColumnStatistics mStatsObj;
-        List<MTableColumnStatistics> mStatsObjColl;
-
+      List<MTableColumnStatistics> mStatsObjColl;
       if (mTable == null) {
-        throw new
-          NoSuchObjectException("Table " + tableName +
-          "  for which stats deletion is requested doesn't exist");
+        throw new NoSuchObjectException("Table " + tableName
+            + "  for which stats deletion is requested doesn't exist");
       }
-
-      Query query = pm.newQuery(MTableColumnStatistics.class);
+      query = pm.newQuery(MTableColumnStatistics.class);
       String filter;
       String parameters;
-
       if (colName != null) {
         filter = "table.tableName == t1 && dbName == t2 && colName == t3";
         parameters = "java.lang.String t1, java.lang.String t2, java.lang.String t3";
@@ -6385,44 +6580,45 @@ public boolean deleteTableColumnStatistics(String dbName, String tableName, Stri
       }
 
       query.setFilter(filter);
-      query
-        .declareParameters(parameters);
-
+      query.declareParameters(parameters);
       if (colName != null) {
         query.setUnique(true);
-        mStatsObj = (MTableColumnStatistics)query.execute(
-            HiveStringUtils.normalizeIdentifier(tableName),
-            HiveStringUtils.normalizeIdentifier(dbName),
-            HiveStringUtils.normalizeIdentifier(colName));
+        mStatsObj =
+            (MTableColumnStatistics) query.execute(HiveStringUtils.normalizeIdentifier(tableName),
+                HiveStringUtils.normalizeIdentifier(dbName),
+                HiveStringUtils.normalizeIdentifier(colName));
         pm.retrieve(mStatsObj);
 
         if (mStatsObj != null) {
           pm.deletePersistent(mStatsObj);
         } else {
-          throw new NoSuchObjectException("Column stats doesn't exist for db=" +dbName + " table="
+          throw new NoSuchObjectException("Column stats doesn't exist for db=" + dbName + " table="
               + tableName + " col=" + colName);
         }
       } else {
-        mStatsObjColl= (List<MTableColumnStatistics>)query.execute(
-            HiveStringUtils.normalizeIdentifier(tableName),
-            HiveStringUtils.normalizeIdentifier(dbName));
+        mStatsObjColl =
+            (List<MTableColumnStatistics>) query.execute(
+                HiveStringUtils.normalizeIdentifier(tableName),
+                HiveStringUtils.normalizeIdentifier(dbName));
         pm.retrieveAll(mStatsObjColl);
-
         if (mStatsObjColl != null) {
           pm.deletePersistentAll(mStatsObjColl);
         } else {
-          throw new NoSuchObjectException("Column stats doesn't exist for db=" + dbName +
-            " table=" + tableName);
+          throw new NoSuchObjectException("Column stats doesn't exist for db=" + dbName + " table="
+              + tableName);
         }
       }
       ret = commitTransaction();
-    } catch(NoSuchObjectException e) {
-       rollbackTransaction();
-       throw e;
+    } catch (NoSuchObjectException e) {
+      rollbackTransaction();
+      throw e;
     } finally {
       if (!ret) {
         rollbackTransaction();
       }
+      if (query != null) {
+        query.closeAll();
+      }
     }
     return ret;
   }
@@ -6430,21 +6626,26 @@ public boolean deleteTableColumnStatistics(String dbName, String tableName, Stri
   @Override
   public long cleanupEvents() {
     boolean commited = false;
+    Query query = null;
     long delCnt;
     LOG.debug("Begin executing cleanupEvents");
-    Long expiryTime = HiveConf.getTimeVar(getConf(), ConfVars.METASTORE_EVENT_EXPIRY_DURATION, TimeUnit.MILLISECONDS);
+    Long expiryTime =
+        HiveConf.getTimeVar(getConf(), ConfVars.METASTORE_EVENT_EXPIRY_DURATION,
+            TimeUnit.MILLISECONDS);
     Long curTime = System.currentTimeMillis();
     try {
       openTransaction();
-      Query query = pm.newQuery(MPartitionEvent.class,"curTime - eventTime > expiryTime");
+      query = pm.newQuery(MPartitionEvent.class, "curTime - eventTime > expiryTime");
       query.declareParameters("java.lang.Long curTime, java.lang.Long expiryTime");
       delCnt = query.deletePersistentAll(curTime, expiryTime);
       commited = commitTransaction();
-    }
-    finally {
+    } finally {
       if (!commited) {
         rollbackTransaction();
       }
+      if (query != null) {
+        query.closeAll();
+      }
       LOG.debug("Done executing cleanupEvents");
     }
     return delCnt;
@@ -6454,7 +6655,11 @@ private MDelegationToken getTokenFrom(String tokenId) {
     Query query = pm.newQuery(MDelegationToken.class, "tokenIdentifier == tokenId");
     query.declareParameters("java.lang.String tokenId");
     query.setUnique(true);
-    return (MDelegationToken)query.execute(tokenId);
+    MDelegationToken delegationToken = (MDelegationToken) query.execute(tokenId);
+    if (query != null) {
+      query.closeAll();
+    }
+    return delegationToken;
   }
 
   @Override
@@ -6526,28 +6731,31 @@ public String getToken(String tokenId) {
 
   @Override
   public List<String> getAllTokenIdentifiers() {
-
     LOG.debug("Begin executing getAllTokenIdentifiers");
     boolean committed = false;
-    List<MDelegationToken> tokens;
-    try{
+    Query query = null;
+    List<String> tokenIdents = new ArrayList<String>();
+
+    try {
       openTransaction();
-      Query query = pm.newQuery(MDelegationToken.class);
-      tokens = (List<MDelegationToken>) query.execute();
+      query = pm.newQuery(MDelegationToken.class);
+      List<MDelegationToken> tokens = (List<MDelegationToken>) query.execute();
       pm.retrieveAll(tokens);
       committed = commitTransaction();
+
+      for (MDelegationToken token : tokens) {
+        tokenIdents.add(token.getTokenIdentifier());
+      }
+      return tokenIdents;
     } finally {
-      if(!committed) {
+      LOG.debug("Done executing getAllTokenIdentifers with status : " + committed);
+      if (!committed) {
         rollbackTransaction();
       }
+      if (query != null) {
+        query.closeAll();
+      }
     }
-    LOG.debug("Done executing getAllTokenIdentifers with status : " + committed);
-    List<String> tokenIdents = new ArrayList<String>(tokens.size());
-
-    for (MDelegationToken token : tokens) {
-      tokenIdents.add(token.getTokenIdentifier());
-    }
-    return tokenIdents;
   }
 
   @Override
@@ -6576,21 +6784,25 @@ public int addMasterKey(String key) throws MetaException{
   public void updateMasterKey(Integer id, String key) throws NoSuchObjectException, MetaException {
     LOG.debug("Begin executing updateMasterKey");
     boolean committed = false;
+    Query query = null;
     MMasterKey masterKey;
-    try{
-    openTransaction();
-    Query query = pm.newQuery(MMasterKey.class, "keyId == id");
-    query.declareParameters("java.lang.Integer id");
-    query.setUnique(true);
-    masterKey = (MMasterKey)query.execute(id);
-    if (null != masterKey) {
-      masterKey.setMasterKey(key);
-    }
-    committed = commitTransaction();
+    try {
+      openTransaction();
+      query = pm.newQuery(MMasterKey.class, "keyId == id");
+      query.declareParameters("java.lang.Integer id");
+      query.setUnique(true);
+      masterKey = (MMasterKey) query.execute(id);
+      if (null != masterKey) {
+        masterKey.setMasterKey(key);
+      }
+      committed = commitTransaction();
     } finally {
-      if(!committed) {
+      if (!committed) {
         rollbackTransaction();
       }
+      if (query != null) {
+        query.closeAll();
+      }
     }
     LOG.debug("Done executing updateMasterKey with status : " + committed);
     if (null == masterKey) {
@@ -6605,21 +6817,25 @@ public void updateMasterKey(Integer id, String key) throws NoSuchObjectException
   public boolean removeMasterKey(Integer id) {
     LOG.debug("Begin executing removeMasterKey");
     boolean success = false;
+    Query query = null;
     MMasterKey masterKey;
-    try{
-    openTransaction();
-    Query query = pm.newQuery(MMasterKey.class, "keyId == id");
-    query.declareParameters("java.lang.Integer id");
-    query.setUnique(true);
-    masterKey = (MMasterKey)query.execute(id);
-    if (null != masterKey) {
-      pm.deletePersistent(masterKey);
-    }
-    success = commitTransaction();
+    try {
+      openTransaction();
+      query = pm.newQuery(MMasterKey.class, "keyId == id");
+      query.declareParameters("java.lang.Integer id");
+      query.setUnique(true);
+      masterKey = (MMasterKey) query.execute(id);
+      if (null != masterKey) {
+        pm.deletePersistent(masterKey);
+      }
+      success = commitTransaction();
     } finally {
-      if(!success) {
+      if (!success) {
         rollbackTransaction();
       }
+      if (query != null) {
+        query.closeAll();
+      }
     }
     LOG.debug("Done executing removeMasterKey with status : " + success);
     return (null != masterKey) && success;
@@ -6629,25 +6845,29 @@ public boolean removeMasterKey(Integer id) {
   public String[] getMasterKeys() {
     LOG.debug("Begin executing getMasterKeys");
     boolean committed = false;
+    Query query = null;
     List<MMasterKey> keys;
-    try{
+    try {
       openTransaction();
-      Query query = pm.newQuery(MMasterKey.class);
+      query = pm.newQuery(MMasterKey.class);
       keys = (List<MMasterKey>) query.execute();
       pm.retrieveAll(keys);
       committed = commitTransaction();
+
+      String[] masterKeys = new String[keys.size()];
+      for (int i = 0; i < keys.size(); i++) {
+        masterKeys[i] = keys.get(i).getMasterKey();
+      }
+      return masterKeys;
     } finally {
-      if(!committed) {
+      LOG.debug("Done executing getMasterKeys with status : " + committed);
+      if (!committed) {
         rollbackTransaction();
       }
+      if (query != null) {
+        query.closeAll();
+      }
     }
-    LOG.debug("Done executing getMasterKeys with status : " + committed);
-    String[] masterKeys = new String[keys.size()];
-
-    for (int i = 0; i < keys.size(); i++) {
-      masterKeys[i] = keys.get(i).getMasterKey();
-    }
-    return masterKeys;
   }
 
   // compare hive version and metastore version
@@ -6723,43 +6943,46 @@ public String getMetaStoreSchemaVersion() throws MetaException {
   }
 
   @SuppressWarnings("unchecked")
-  private MVersionTable getMSchemaVersion()
-      throws NoSuchObjectException, MetaException {
+  private MVersionTable getMSchemaVersion() throws NoSuchObjectException, MetaException {
     boolean committed = false;
+    Query query = null;
     List<MVersionTable> mVerTables = new ArrayList<MVersionTable>();
-
     try {
       openTransaction();
-      Query query = pm.newQuery(MVersionTable.class);
-
+      query = pm.newQuery(MVersionTable.class);
       try {
-        mVerTables = (List<MVersionTable>)query.execute();
+        mVerTables = (List<MVersionTable>) query.execute();
         pm.retrieveAll(mVerTables);
       } catch (JDODataStoreException e) {
         if (e.getCause() instanceof MissingTableException) {
-          throw new MetaException("Version table not found. " +
-              "The metastore is not upgraded to " + MetaStoreSchemaInfo.getHiveSchemaVersion());
+          throw new MetaException("Version table not found. " + "The metastore is not upgraded to "
+              + MetaStoreSchemaInfo.getHiveSchemaVersion());
         } else {
           throw e;
         }
       }
       committed = commitTransaction();
+      if (mVerTables.isEmpty()) {
+        throw new NoSuchObjectException("No matching version found");
+      }
+      if (mVerTables.size() > 1) {
+        String msg = "Metastore contains multiple versions (" + mVerTables.size() + ") ";
+        for (MVersionTable version : mVerTables) {
+          msg +=
+              "[ version = " + version.getSchemaVersion() + ", comment = "
+                  + version.getVersionComment() + " ] ";
+        }
+        throw new MetaException(msg.trim());
+      }
+      return mVerTables.get(0);
     } finally {
       if (!committed) {
         rollbackTransaction();
       }
-    }
-    if (mVerTables.isEmpty()) {
-      throw new NoSuchObjectException("No matching version found");
-    }
-    if (mVerTables.size() > 1) {
-      String msg = "Metastore contains multiple versions (" + mVerTables.size() + ") ";
-      for (MVersionTable version : mVerTables) {
-        msg += "[ version = " + version.getSchemaVersion() + ", comment = " + version.getVersionComment() + " ] ";
+      if (query != null) {
+        query.closeAll();
       }
-      throw new MetaException(msg.trim());
     }
-    return mVerTables.get(0);
   }
 
   @Override
@@ -6798,6 +7021,7 @@ public void setMetaStoreSchemaVersion(String schemaVersion, String comment) thro
   public boolean doesPartitionExist(String dbName, String tableName, List<String> partVals)
       throws MetaException {
     boolean success = false;
+    Query query = null;
     try {
       openTransaction();
       dbName = HiveStringUtils.normalizeIdentifier(dbName);
@@ -6809,22 +7033,24 @@ public boolean doesPartitionExist(String dbName, String tableName, List<String>
         success = commitTransaction();
         return false;
       }
-
-      Query query = pm.newQuery(
-          "select partitionName from org.apache.hadoop.hive.metastore.model.MPartition "
-          + "where table.tableName == t1 && table.database.name == t2 && partitionName == t3");
+      query =
+          pm.newQuery("select partitionName from org.apache.hadoop.hive.metastore.model.MPartition "
+              + "where table.tableName == t1 && table.database.name == t2 && partitionName == t3");
       query.declareParameters("java.lang.String t1, java.lang.String t2, java.lang.String t3");
       query.setUnique(true);
       query.setResult("partitionName");
-      String name = Warehouse.makePartName(
-          convertToFieldSchemas(mtbl.getPartitionKeys()), partVals);
-      String result = (String)query.execute(tableName, dbName, name);
+      String name =
+          Warehouse.makePartName(convertToFieldSchemas(mtbl.getPartitionKeys()), partVals);
+      String result = (String) query.execute(tableName, dbName, name);
       success = commitTransaction();
       return result != null;
     } finally {
       if (!success) {
         rollbackTransaction();
       }
+      if (query != null) {
+        query.closeAll();
+      }
     }
   }
 
@@ -6995,11 +7221,12 @@ public void dropFunction(String dbName, String funcName) throws MetaException,
   private MFunction getMFunction(String db, String function) {
     MFunction mfunc = null;
     boolean commited = false;
+    Query query = null;
     try {
       openTransaction();
       db = HiveStringUtils.normalizeIdentifier(db);
       function = HiveStringUtils.normalizeIdentifier(function);
-      Query query = pm.newQuery(MFunction.class, "functionName == function && database.name == db");
+      query = pm.newQuery(MFunction.class, "functionName == function && database.name == db");
       query.declareParameters("java.lang.String function, java.lang.String db");
       query.setUnique(true);
       mfunc = (MFunction) query.execute(function, db);
@@ -7009,6 +7236,9 @@ private MFunction getMFunction(String db, String function) {
       if (!commited) {
         rollbackTransaction();
       }
+      if (query != null) {
+        query.closeAll();
+      }
     }
     return mfunc;
   }
@@ -7030,9 +7260,9 @@ public Function getFunction(String dbName, String funcName) throws MetaException
   }
 
   @Override
-  public List<String> getFunctions(String dbName, String pattern)
-      throws MetaException {
+  public List<String> getFunctions(String dbName, String pattern) throws MetaException {
     boolean commited = false;
+    Query query = null;
     List<String> funcs = null;
     try {
       openTransaction();
@@ -7040,25 +7270,24 @@ public Function getFunction(String dbName, String funcName) throws MetaException
       // Take the pattern and split it on the | to get all the composing
       // patterns
       String[] subpatterns = pattern.trim().split("\\|");
-      String query =
-        "select functionName from org.apache.hadoop.hive.metastore.model.MFunction "
-        + "where database.name == dbName && (";
+      String queryStr =
+          "select functionName from org.apache.hadoop.hive.metastore.model.MFunction "
+              + "where database.name == dbName && (";
       boolean first = true;
       for (String subpattern : subpatterns) {
         subpattern = "(?i)" + subpattern.replaceAll("\\*", ".*");
         if (!first) {
-          query = query + " || ";
+          queryStr = queryStr + " || ";
         }
-        query = query + " functionName.matches(\"" + subpattern + "\")";
+        queryStr = queryStr + " functionName.matches(\"" + subpattern + "\")";
         first = false;
       }
-      query = query + ")";
-
-      Query q = pm.newQuery(query);
-      q.declareParameters("java.lang.String dbName");
-      q.setResult("functionName");
-      q.setOrdering("functionName ascending");
-      Collection names = (Collection) q.execute(dbName);
+      queryStr = queryStr + ")";
+      query = pm.newQuery(queryStr);
+      query.declareParameters("java.lang.String dbName");
+      query.setResult("functionName");
+      query.setOrdering("functionName ascending");
+      Collection names = (Collection) query.execute(dbName);
       funcs = new ArrayList<String>();
       for (Iterator i = names.iterator(); i.hasNext();) {
         funcs.add((String) i.next());
@@ -7068,6 +7297,9 @@ public Function getFunction(String dbName, String funcName) throws MetaException
       if (!commited) {
         rollbackTransaction();
       }
+      if (query != null) {
+        query.closeAll();
+      }
     }
     return funcs;
   }
@@ -7075,13 +7307,14 @@ public Function getFunction(String dbName, String funcName) throws MetaException
   @Override
   public NotificationEventResponse getNextNotification(NotificationEventRequest rqst) {
     boolean commited = false;
+    Query query = null;
     try {
       openTransaction();
       long lastEvent = rqst.getLastEvent();
-      Query query = pm.newQuery(MNotificationLog.class, "eventId > lastEvent");
+      query = pm.newQuery(MNotificationLog.class, "eventId > lastEvent");
       query.declareParameters("java.lang.Long lastEvent");
       query.setOrdering("eventId ascending");
-      Collection<MNotificationLog> events = (Collection)query.execute(lastEvent);
+      Collection<MNotificationLog> events = (Collection) query.execute(lastEvent);
       commited = commitTransaction();
       if (events == null) {
         return null;
@@ -7095,6 +7328,9 @@ public NotificationEventResponse getNextNotification(NotificationEventRequest rq
       }
       return result;
     } finally {
+      if (query != null) {
+        query.closeAll();
+      }
       if (!commited) {
         rollbackTransaction();
         return null;
@@ -7105,9 +7341,10 @@ public NotificationEventResponse getNextNotification(NotificationEventRequest rq
   @Override
   public void addNotificationEvent(NotificationEvent entry) {
     boolean commited = false;
+    Query query = null;
     try {
       openTransaction();
-      Query query = pm.newQuery(MNotificationNextId.class);
+      query = pm.newQuery(MNotificationNextId.class);
       Collection<MNotificationNextId> ids = (Collection) query.execute();
       MNotificationNextId id = null;
       boolean needToPersistId;
@@ -7120,26 +7357,31 @@ public void addNotificationEvent(NotificationEvent entry) {
       }
       entry.setEventId(id.getNextEventId());
       id.incrementEventId();
-      if (needToPersistId) pm.makePersistent(id);
+      if (needToPersistId)
+        pm.makePersistent(id);
       pm.makePersistent(translateThriftToDb(entry));
       commited = commitTransaction();
     } finally {
       if (!commited) {
         rollbackTransaction();
       }
+      if (query != null) {
+        query.closeAll();
+      }
     }
   }
 
   @Override
   public void cleanNotificationEvents(int olderThan) {
     boolean commited = false;
+    Query query = null;
     try {
       openTransaction();
       long tmp = System.currentTimeMillis() / 1000 - olderThan;
-      int tooOld = (tmp > Integer.MAX_VALUE) ? 0 : (int)tmp;
-      Query query = pm.newQuery(MNotificationLog.class, "eventTime < tooOld");
+      int tooOld = (tmp > Integer.MAX_VALUE) ? 0 : (int) tmp;
+      query = pm.newQuery(MNotificationLog.class, "eventTime < tooOld");
       query.declareParameters("java.lang.Integer tooOld");
-      Collection<MNotificationLog> toBeRemoved = (Collection)query.execute(tooOld);
+      Collection<MNotificationLog> toBeRemoved = (Collection) query.execute(tooOld);
       if (toBeRemoved != null && toBeRemoved.size() > 0) {
         pm.deletePersistent(toBeRemoved);
       }
@@ -7148,16 +7390,20 @@ public void cleanNotificationEvents(int olderThan) {
       if (!commited) {
         rollbackTransaction();
       }
+      if (query != null) {
+        query.closeAll();
+      }
     }
   }
 
   @Override
   public CurrentNotificationEventId getCurrentNotificationEventId() {
     boolean commited = false;
+    Query query = null;
     try {
       openTransaction();
-      Query query = pm.newQuery(MNotificationNextId.class);
-      Collection<MNotificationNextId> ids = (Collection)query.execute();
+      query = pm.newQuery(MNotificationNextId.class);
+      Collection<MNotificationNextId> ids = (Collection) query.execute();
       long id = 0;
       if (ids != null && ids.size() > 0) {
         id = ids.iterator().next().getNextEventId() - 1;
@@ -7168,6 +7414,9 @@ public CurrentNotificationEventId getCurrentNotificationEventId() {
       if (!commited) {
         rollbackTransaction();
       }
+      if (query != null) {
+        query.closeAll();
+      }
     }
   }
 
@@ -7192,7 +7441,4 @@ private NotificationEvent translateDbToThrift(MNotificationLog dbEvent) {
     event.setMessage((dbEvent.getMessage()));
     return event;
   }
-
-
-
 }
diff --git a/metastore/src/java/org/apache/hadoop/hive/metastore/tools/HiveMetaTool.java b/metastore/src/java/org/apache/hadoop/hive/metastore/tools/HiveMetaTool.java
index d0ff329..411ac21 100644
--- a/metastore/src/java/org/apache/hadoop/hive/metastore/tools/HiveMetaTool.java
+++ b/metastore/src/java/org/apache/hadoop/hive/metastore/tools/HiveMetaTool.java
@@ -149,16 +149,21 @@ private void executeJDOQLSelect(String query) {
     initObjectStore(hiveConf);
 
     System.out.println("Executing query: " + query);
-    Collection<?> result = objStore.executeJDOQLSelect(query);
-    if (result != null) {
-      Iterator<?> iter = result.iterator();
-      while (iter.hasNext()) {
-        Object o = iter.next();
-        System.out.println(o.toString());
+    ObjectStore.QueryWrapper queryWrapper = new ObjectStore.QueryWrapper();
+    try {
+      Collection<?> result = objStore.executeJDOQLSelect(query, queryWrapper);
+      if (result != null) {
+        Iterator<?> iter = result.iterator();
+        while (iter.hasNext()) {
+          Object o = iter.next();
+          System.out.println(o.toString());
+        }
+      } else {
+        System.err.println("Encountered error during executeJDOQLSelect -" +
+          "commit of JDO transaction failed.");
       }
-    } else {
-      System.err.println("Encountered error during executeJDOQLSelect -" +
-        "commit of JDO transaction failed.");
+    } finally {
+      queryWrapper.close();
     }
   }
 
diff --git a/metastore/src/test/org/apache/hadoop/hive/metastore/TestObjectStore.java b/metastore/src/test/org/apache/hadoop/hive/metastore/TestObjectStore.java
new file mode 100644
index 0000000..2c1ee76
--- /dev/null
+++ b/metastore/src/test/org/apache/hadoop/hive/metastore/TestObjectStore.java
@@ -0,0 +1,228 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hive.metastore;
+
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+
+import org.apache.hadoop.hive.conf.HiveConf;
+import org.apache.hadoop.hive.metastore.api.Database;
+import org.apache.hadoop.hive.metastore.api.FieldSchema;
+import org.apache.hadoop.hive.metastore.api.InvalidInputException;
+import org.apache.hadoop.hive.metastore.api.InvalidObjectException;
+import org.apache.hadoop.hive.metastore.api.MetaException;
+import org.apache.hadoop.hive.metastore.api.NoSuchObjectException;
+import org.apache.hadoop.hive.metastore.api.Partition;
+import org.apache.hadoop.hive.metastore.api.PrincipalType;
+import org.apache.hadoop.hive.metastore.api.Role;
+import org.apache.hadoop.hive.metastore.api.SerDeInfo;
+import org.apache.hadoop.hive.metastore.api.StorageDescriptor;
+import org.apache.hadoop.hive.metastore.api.Table;
+import org.apache.hadoop.hive.serde2.typeinfo.PrimitiveTypeInfo;
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+
+public class TestObjectStore {
+  private ObjectStore objectStore = null;
+
+  private static final String DB1 = "testobjectstoredb1";
+  private static final String DB2 = "testobjectstoredb2";
+  private static final String TABLE1 = "testobjectstoretable1";
+  private static final String KEY1 = "testobjectstorekey1";
+  private static final String KEY2 = "testobjectstorekey2";
+  private static final String OWNER = "testobjectstoreowner";
+  private static final String USER1 = "testobjectstoreuser1";
+  private static final String ROLE1 = "testobjectstorerole1";
+  private static final String ROLE2 = "testobjectstorerole2";
+
+  public static class MockPartitionExpressionProxy implements PartitionExpressionProxy {
+    @Override
+    public String convertExprToFilter(byte[] expr) throws MetaException {
+      return null;
+    }
+
+    @Override
+    public boolean filterPartitionsByExpr(List<String> partColumnNames,
+        List<PrimitiveTypeInfo> partColumnTypeInfos, byte[] expr,
+        String defaultPartitionName, List<String> partitionNames)
+        throws MetaException {
+      return false;
+    }
+  }
+
+  @Before
+  public void setUp() {
+    HiveConf conf = new HiveConf();
+    conf.setVar(HiveConf.ConfVars.METASTORE_EXPRESSION_PROXY_CLASS, MockPartitionExpressionProxy.class.getName());
+
+    objectStore = new ObjectStore();
+    objectStore.setConf(conf);
+
+    try {
+      objectStore.dropDatabase(DB1);
+    } catch (Exception e) {
+    }
+    try {
+      objectStore.dropDatabase(DB2);
+    } catch (Exception e) {
+    }
+  }
+
+  @After
+  public void tearDown() {
+  }
+
+  /**
+   * Test database operations
+   */
+  @Test
+  public void testDatabaseOps() throws MetaException, InvalidObjectException, NoSuchObjectException {
+    Database db1 = new Database(DB1, "description", "locationurl", null);
+    Database db2 = new Database(DB2, "description", "locationurl", null);
+    objectStore.createDatabase(db1);
+    objectStore.createDatabase(db2);
+
+    List<String> databases = objectStore.getAllDatabases();
+    Assert.assertEquals(2, databases.size());
+    Assert.assertEquals(DB1, databases.get(0));
+    Assert.assertEquals(DB2, databases.get(1));
+
+    objectStore.dropDatabase(DB1);
+    databases = objectStore.getAllDatabases();
+    Assert.assertEquals(1, databases.size());
+    Assert.assertEquals(DB2, databases.get(0));
+
+    objectStore.dropDatabase(DB2);
+  }
+
+  /**
+   * Test table operations
+   */
+  @Test
+  public void testTableOps() throws MetaException, InvalidObjectException, NoSuchObjectException, InvalidInputException {
+    Database db1 = new Database(DB1, "description", "locationurl", null);
+    objectStore.createDatabase(db1);
+    StorageDescriptor sd = new StorageDescriptor(null, "location", null, null, false, 0, new SerDeInfo("SerDeName", "serializationLib", null), null, null, null);
+    HashMap<String,String> params = new HashMap<String,String>();
+    params.put("EXTERNAL", "false");
+    Table tbl1 = new Table(TABLE1, DB1, "owner", 1, 2, 3, sd, null, params, "viewOriginalText", "viewExpandedText", "MANAGED_TABLE");
+    objectStore.createTable(tbl1);
+
+    List<String> tables = objectStore.getAllTables(DB1);
+    Assert.assertEquals(1, tables.size());
+    Assert.assertEquals(TABLE1, tables.get(0));
+
+    Table newTbl1 = new Table("new" + TABLE1, DB1, "owner", 1, 2, 3, sd, null, params, "viewOriginalText", "viewExpandedText", "MANAGED_TABLE");
+    objectStore.alterTable(DB1, TABLE1, newTbl1);
+    tables = objectStore.getTables(DB1, "new*");
+    Assert.assertEquals(1, tables.size());
+    Assert.assertEquals("new" + TABLE1, tables.get(0));
+
+    objectStore.dropTable(DB1, "new" + TABLE1);
+    tables = objectStore.getAllTables(DB1);
+    Assert.assertEquals(0, tables.size());
+
+    objectStore.dropDatabase(DB1);
+  }
+
+  /**
+   * Tests partition operations
+   */
+  @Test
+  public void testPartitionOps() throws MetaException, InvalidObjectException, NoSuchObjectException, InvalidInputException {
+    Database db1 = new Database(DB1, "description", "locationurl", null);
+    objectStore.createDatabase(db1);
+    StorageDescriptor sd = new StorageDescriptor(null, "location", null, null, false, 0, new SerDeInfo("SerDeName", "serializationLib", null), null, null, null);
+    HashMap<String,String> tableParams = new HashMap<String,String>();
+    tableParams.put("EXTERNAL", "false");
+    FieldSchema partitionKey1 = new FieldSchema("Country", "String", "");
+    FieldSchema partitionKey2 = new FieldSchema("State", "String", "");
+    Table tbl1 = new Table(TABLE1, DB1, "owner", 1, 2, 3, sd, Arrays.asList(partitionKey1, partitionKey2), tableParams, "viewOriginalText", "viewExpandedText", "MANAGED_TABLE");
+    objectStore.createTable(tbl1);
+    HashMap<String, String> partitionParams = new HashMap<String, String>();
+    partitionParams.put("PARTITION_LEVEL_PRIVILEGE", "true");
+    List<String> value1 = Arrays.asList("US", "CA");
+    Partition part1 = new Partition(value1, DB1, TABLE1, 111, 111, sd, partitionParams);
+    objectStore.addPartition(part1);
+    List<String> value2 = Arrays.asList("US", "MA");
+    Partition part2 = new Partition(value2, DB1, TABLE1, 222, 222, sd, partitionParams);
+    objectStore.addPartition(part2);
+
+    List<Partition> partitions = objectStore.getPartitions(DB1, TABLE1, 10);
+    Assert.assertEquals(2, partitions.size());
+    Assert.assertEquals(111, partitions.get(0).getCreateTime());
+    Assert.assertEquals(222, partitions.get(1).getCreateTime());
+
+    objectStore.dropPartition(DB1, TABLE1, value1);
+    partitions = objectStore.getPartitions(DB1, TABLE1, 10);
+    Assert.assertEquals(1, partitions.size());
+    Assert.assertEquals(222, partitions.get(0).getCreateTime());
+
+    objectStore.dropPartition(DB1, TABLE1, value2);
+    objectStore.dropTable(DB1, TABLE1);
+    objectStore.dropDatabase(DB1);
+  }
+
+  /**
+   * Test master keys operation
+   */
+  @Test
+  public void testMasterKeyOps() throws MetaException, NoSuchObjectException {
+    int id1 = objectStore.addMasterKey(KEY1);
+    int id2 = objectStore.addMasterKey(KEY2);
+
+    String[] keys = objectStore.getMasterKeys();
+    Assert.assertEquals(2, keys.length);
+    Assert.assertEquals(KEY1, keys[0]);
+    Assert.assertEquals(KEY2, keys[1]);
+
+    objectStore.updateMasterKey(id1, "new" + KEY1);
+    objectStore.updateMasterKey(id2, "new" + KEY2);
+    keys = objectStore.getMasterKeys();
+    Assert.assertEquals(2, keys.length);
+    Assert.assertEquals("new" + KEY1, keys[0]);
+    Assert.assertEquals("new" + KEY2, keys[1]);
+
+    objectStore.removeMasterKey(id1);
+    keys = objectStore.getMasterKeys();
+    Assert.assertEquals(1, keys.length);
+    Assert.assertEquals("new" + KEY2, keys[0]);
+
+    objectStore.removeMasterKey(id2);
+  }
+
+  /**
+   * Test role operation
+   */
+  @Test
+  public void testRoleOps() throws InvalidObjectException, MetaException, NoSuchObjectException {
+    objectStore.addRole(ROLE1, OWNER);
+    objectStore.addRole(ROLE2, OWNER);
+    List<String> roles = objectStore.listRoleNames();
+    Assert.assertEquals(2, roles.size());
+    Assert.assertEquals(ROLE2, roles.get(1));
+    Role role1 = objectStore.getRole(ROLE1);
+    Assert.assertEquals(OWNER, role1.getOwnerName());
+    objectStore.grantRole(role1, USER1, PrincipalType.USER, OWNER, PrincipalType.ROLE, true);
+    objectStore.revokeRole(role1, USER1, PrincipalType.USER, false);
+    objectStore.removeRole(ROLE1);
+  }
+}
-- 
1.7.9.5

